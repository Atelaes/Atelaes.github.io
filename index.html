<html>
<meta charset="utf-8">
<head>
  <style>
    @import url("jekyll-theme-midnight.scss");
    body {
      margin : 10px;
      /*background-color: dimgrey;
      color: white;*/
      }
    .projectSelector {
      margin-left: 1px;
      margin-right: 1px;
      padding-right: 10px;
      padding-left: 10px;
      padding-bottom: 1px;
      border-top: solid black 1px;
      border-right: solid black 1px;
      border-left: solid black 1px;
      border-top-left-radius: 5px;
      border-top-right-radius: 5px;

      }

    .unselectedSelector {
      background: #202020;
      border-bottom: solid black 1px;
      }
    .psLine {
      margin: 15px;
      /*border-bottom: solid black 1px;*/
      }
    h1 {text-align: center}
    .hiddenProject { display: none; }
    .shownProject { display: block;}
  </style>
  <script>
    var currentProject = 0;
    function addSelectorEvent() {
      var projectSelectors = document.getElementsByClassName("projectSelector");
      for (i=0; i<projectSelectors.length; i++) {
        var projectSelector = projectSelectors[i];
        projectSelector.addEventListener("mouseover", fingerMouse);
        projectSelector.addEventListener("mouseout", regularMouse);
        projectSelector.addEventListener("click", psClick);
        }
      }

    function fingerMouse() {
      document.body.style.cursor = "pointer";
      }

    function regularMouse() {
      document.body.style.cursor = "auto";
      }

    function psClick(e) {
      var currentProjectNumber = currentProject;
      var currentProjectSelectorId = "ps" + currentProjectNumber;
      var currentProjectSelector = document.getElementById(currentProjectSelectorId);
      if (currentProjectSelector) {currentProjectSelector.classList.add("unselectedSelector");}
      var currentProjectName = "projectDisplay" + currentProjectNumber;
      var currentProjectDiv = document.getElementById(currentProjectName);
      currentProjectDiv.className = "hiddenProject";
      e.target.classList.remove("unselectedSelector");
      var projectTab = e.target.id;
      var idnum = projectTab.substr(-1);
      var targetProjectName = "projectDisplay" + idnum;
      var targetProjectDiv = document.getElementById(targetProjectName);
      targetProjectDiv.className = "shownProject";
      currentProject = idnum;
    }

    window.onload = addSelectorEvent;
  </script>
</head>
<body>
  <h1>Jesse Halvorsen</h1>
  <h1>Portfolio</h1>
  <div class="psLine">
    <span>Projects: </span>
    <span class="projectSelector unselectedSelector" id="ps1">Scheduler</span>
    <span class="projectSelector unselectedSelector" id='ps2'>Viking</span>
    <span class="projectSelector unselectedSelector" id='ps3'>Pronunciation</span>
    <span class="projectSelector unselectedSelector" id='ps4'>Quotations</span>
    <span class="projectSelector unselectedSelector" id='ps5'>Tag Deletion Report</span>
    <span class="projectSelector unselectedSelector" id='ps6'>Purchase Journal Report</span>
  </div>
  <div id="projectDisplay0" class="shownProject">
    <br />Click on a tab to view a project.
  </div>

  <div id="projectDisplay1" class="hiddenProject">
    <div><span>Title: </span><span>Home Depot Schedule Writer</span></div>
    <div><span>Language: </span><span>Python</span></div>
    <div><span>Purpose: </span><span>Pulls my personal work schedule from the Home Depot's website, and uploads it to my Google Calendar.</span></div>
    <div><span>Description: For better or worse, the Home Depot schedule site takes the login information simply as part of the url.  I then use Beautiful Soup to traverse the DOM (finding a DOM manipulator that worked the way I wanted was tricky), and extract the dates.  I convert the dates into the ISO format that Google Calendar likes, and then compare each date on the HD schedule with that same date on my Google Calendar, and add, subtract, or modify as needed.  Google access is done through OAuth.  The program then uses the same Google access to send me an email (from my email address) if there are any changes or errors.  It's attached to a Windows login event, and so runs every time I log on to my computer.</span><span></span></div>
    <figure>
    <pre>
<code>
  from __future__ import print_function
  import requests
  from bs4 import BeautifulSoup
  import httplib2
  import os
  import re
  import datetime
  import pytz
  import json
  import base64
  from email.mime.text import MIMEText

  from apiclient import discovery
  from oauth2client import client
  from oauth2client import tools
  from oauth2client.file import Storage


  try:
      import argparse
      flags = argparse.ArgumentParser(parents=[tools.argparser]).parse_args()
  except ImportError:
      flags = None

  def pullHDSchedule():
      '''Pulls Home Depot schedule site, parses schedule info from it,
      and returns info as a dictionary.
      '''

      # Start by pulling the schedule HTML from the site
      HDLogin = {'j_storenumber' : '2806', 'j_username' : 'jhl9wf', 'j_password' : 'ha/mazDepos/tum', 'successUrl' : 'https://hdapps.homedepot.com/LaborMgtTools/WFMEssLauncher?language=en_US'}
      site = requests.post('https://hdapps.homedepot.com/MYTHDPassport/rs/clientUI/thdLoginRequest', data=HDLogin, timeout=10)
      code = site.text

      # Now that we have the html, extract the schedule info from it,
      # put it into a nice dictionary
      dom = BeautifulSoup(code, 'html.parser')
      schedule_container = dom.find_all('div', 'dates')[0]
      entries = schedule_container.find_all('li')
      days = []
      for entry in entries:
          # There are eight date-divs per week, seven contain schedule info,
          # one is for site UI.
          if (len(entry.find_all('div', class_='date')) == 1) and (entry.attrs == {}) or ('small' not in entry['class']):
              this_day = {}
              date_node = entry.find_all('div', class_='date')[0]
              this_day['date'] = date_node.string
              # Days off have a date div, but lack an hours span.
              if (len(entry.find_all('span', class_='hours')) &gt; 0):
                  hours_node = entry.find_all('span', class_='hours')[0]
                  this_day['hours'] = hours_node.string
                  # Special days (split shifts, cross-clocks, training, etc.)
                  # have multiple items in their hours span,
                  # and thus return None for hours_node.string
                  # Find the item with the shift, store it in the hours spot,
                  # and then pull the extra info.
                  if hours_node.string == None:
                      for string in hours_node.strings:
                          if re.findall(r'\d{1,2}:\d{2}[a,p] - \d{1,2}:\d{2}[a,p]', string):
                              this_day['hours'] = string
                      extra_node = entry.find_all('div', class_='extra')[0]
                      extra_info = ''
                      for string in extra_node.stripped_strings:
                          extra_info += string + ' '
                      extra_info = extra_info.replace('.', u'\u00A0') #non-breaking space
                      this_day['extra'] = extra_info
              days.append(this_day)
      return days

  def get_credentials():
      &quot;&quot;&quot;Gets valid user credentials from storage.

      If nothing has been stored, or if the stored credentials are invalid,
      the OAuth2 flow is completed to obtain the new credentials.

      Returns:
          Credentials, the obtained credential.
      &quot;&quot;&quot;

      SCOPES = 'https://www.googleapis.com/auth/calendar https://www.googleapis.com/auth/gmail.modify'
      CLIENT_SECRET_FILE = 'client_secret.json'
      APPLICATION_NAME = 'AtelaesHDScheduleScraper'
      credential_path = 'HDScrapeUserCredentials.json'

      store = Storage(credential_path)
      credentials = store.get()
      if not credentials or credentials.invalid:
          flow = client.flow_from_clientsecrets(CLIENT_SECRET_FILE, SCOPES)
          flow.user_agent = APPLICATION_NAME
          if flags:
              credentials = tools.run_flow(flow, store, flags)
          else: # Needed only for compatibility with Python 2.6
              credentials = tools.run(flow, store)
          print('Storing credentials to ' + credential_path)
      return credentials

  def createGoogleCalendarObject(start, end, entry):
      work_event = {
          'start': {'dateTime' : start},
          'end': {'dateTime' : end},
          'location': '5800 Cedar Lake Road, St. Louis Park, MN 55416',
          'reminders': {
              'useDefault': False,
              'overrides': []
              },
          'colorId': '6'
          }

      hour_components = re.findall(r'\d{1,2}|[a,p]', entry['hours'])
      if hour_components[1] == '00':
          title_start = hour_components[0]
      else:
          title_start = hour_components[0] + ':' + hour_components[1]
      if hour_components[4] == '00':
          title_end = hour_components[3]
      else:
          title_end = hour_components[3] + ':' + hour_components[4]
      work_event['summary'] = 'Work ' + title_start + '-' + title_end

      if 'extra' in entry:
          work_event['summary'] += ' *'
          work_event['description'] = entry['extra']


      return work_event

  def GoogleCalendarInterface(work_instances):
      '''Takes Home Depot schedule data and
      uploads it to Google Calendar.
      '''

      log = {}
      def logAdjust(event):
          if event in log:
              log[event].append(date)
          else:
              log[event] = [date]

      # Start by pulling Google credentials
      credentials = get_credentials()
      http = credentials.authorize(httplib2.Http())
      service = discovery.build('calendar', 'v3', http=http)

      # Set up some timestamp stuff
      year = datetime.datetime.now().year
      day_delta = datetime.timedelta(1)
      central_tz = pytz.timezone('US/Central')

      # Run a loop for each day on the HD calendar
      for work_instance in work_instances:
          date = work_instance['date']
          # If it's currently Dec, and the schedule's in January, we need to increment the year.
          #But only do it once, as it should persist.
          if (year == datetime.datetime.now().year) and (int(date[0:2]) == 1) and (datetime.datetime.now().month == 12):
              year += 1
          day_start = central_tz.localize(datetime.datetime(year, int(date[0:2]), int(date[3:5]), 0, 0, 0, 0))
          day_start_stamp = day_start.isoformat()
          day_end = day_start + day_delta
          day_end_stamp = day_end.isoformat()
          HDhours = False
          # If there's a shift scheduled on this day, create time objects
          # and time stamps for beginning and end of shift.
          if 'hours' in work_instance:
              HDhours = True
              schedule_components = re.findall(r'\d{1,2}|[a,p]', work_instance['hours'])
              # Shifts starting at midnight could be tricky
              if schedule_components[2] == 'p' and int(schedule_components[0]) &lt; 12:
                  work_start_hour = int(schedule_components[0]) + 12
              elif int(schedule_components[3]) == 12: #Starting midnight should be treated as 0:00.
                  work_start_hour = 0
              else:
                  work_start_hour = int(schedule_components[0])
              work_start = central_tz.localize(datetime.datetime(year, int(date[0:2]), int(date[3:5]), work_start_hour, int(schedule_components[1]), 0, 0))
              work_start_string = work_start.isoformat()

              work_end_day = int(date[3:5])
              if schedule_components[5] == 'p' and int(schedule_components[3]) &lt; 12:
                  work_end_hour = int(schedule_components[3]) + 12
              # If the shift starts in pm, and end in am, then we've moved to the next day, and need to adjust the day accordlingly.
              # Midnight is, as usual, special.
              elif schedule_components[5] == 'a' and schedule_components[2] == 'p':
                  work_end_day += 1   #!!!!!!!!This will break on the last of the month!!!!!!!  Fix it!!!!!!!!!
                  if int(schedule_components[3]) == 12:
                      work_end_hour = 0
                  else:
                      work_end_hour = int(schedule_components[3])
              else:
                  work_end_hour = int(schedule_components[3])
              work_end = central_tz.localize(datetime.datetime(year, int(date[0:2]), work_end_day, work_end_hour, int(schedule_components[4]), 0))
              work_end_string = work_end.isoformat()

          # Now check Google calendar and see if there's already a work event
          google_work_schedule = None
          scheduled_events_list = service.events().list(
              calendarId='primary', timeMin=day_start_stamp, timeMax=day_end_stamp).execute()
          scheduled_events = scheduled_events_list.get('items', [])
          for scheduled_event in scheduled_events:
              if scheduled_event['summary'][0:4] == 'Work':
                  google_work_schedule = scheduled_event

          # Forked routines based on whether HD and/or Google have shifts for that day
          # If both have a work shift, compare them.
          if HDhours and google_work_schedule:
              scheduled_event_start_string = scheduled_event['start']['dateTime']
              scheduled_event_start = datetime.datetime.strptime(re.sub('[:]', '', scheduled_event_start_string), '%Y-%m-%dT%H%M%S%z')
              scheduled_event_end_string = scheduled_event['end']['dateTime']
              scheduled_event_end = datetime.datetime.strptime(re.sub('[:]', '', scheduled_event_end_string), '%Y-%m-%dT%H%M%S%z')
              start_match = (scheduled_event_start == work_start)
              end_match = (scheduled_event_end == work_end)

              # If they both match nothing needs to be done.
              if start_match and end_match:
                  logAdjust('match')
              # If they don't, change Google to match HD.
              else:
                  work_event = createGoogleCalendarObject(work_start_string, work_end_string, work_instance)
                  event = service.events().update(calendarId='primary', eventId=google_work_schedule['id'], sendNotifications=True, body=work_event).execute()
                  logAdjust('change')

          # If HD has a shift that Google doesn't, upload it.
          elif HDhours:
              work_event = createGoogleCalendarObject(work_start_string, work_end_string, work_instance)
              event = service.events().insert(calendarId='primary', body=work_event, sendNotifications=True).execute()
              logAdjust('add')

          # If Google has a shift HD doesn't, delete it.
          elif google_work_schedule:
              event = service.events().delete(calendarId='primary', eventId=google_work_schedule['id']).execute()
              logAdjust('delete')

          # If they both say we have a day off, do nothing.
          else:
              logAdjust('match')

      return log

  def sendMail(messageText):
      credentials = get_credentials()
      http = credentials.authorize(httplib2.Http())
      service = discovery.build('gmail', 'v1', http=http)
      message = MIMEText(messageText)
      message['to'] = 'atelaes@gmail.com'
      message['from'] = 'atelaes@gmail.com'
      message['subject'] = 'Calendar Update'
      #The following is esoteric black magic.  Do not fuck with it.
      encodedMessage = {'raw': base64.urlsafe_b64encode(message.as_bytes()).decode()}
      email = (service.users().messages().send(userId='me', body=encodedMessage).execute())


  def main():
      logData = {}
      needToMail = False
      mailMessage = ''
      try:
          HDSchedData = pullHDSchedule()
      except Exception as HDError:
          logData['HDErrorCount'] = 1
          logData['HDErrors'] = str(HDError)
      else:
          try:
              GoogleLog = GoogleCalendarInterface(HDSchedData)
          except Exception as GoogleError:
              logData['GoogleErrorCount'] = 1
              logData['GoogleErrors'] = str(GoogleError)
          else:
              # Most likely scenario is we find that the schedule from Home Depot matches Google's for all days.
              if (len(GoogleLog) == 1) and ('match' in GoogleLog) and (len(GoogleLog['match']) == len(HDSchedData)):
                  logData['Unexceptional'] = 1
              # The other expected possibility is that we found something interesting.
              elif len(GoogleLog) &gt; 1:
                  changeString = ''
                  for changeType in ['change', 'add', 'delete']:
                      if changeType in GoogleLog:
                          changeString += changeType + ': ' + str(GoogleLog[changeType])
                  logData['changeCount'] = 1
                  logData['changes'] = changeString
                  needToMail = True
                  mailMessage += 'Schedule update: ' + changeString
              # Anything else is weird, note it in the log.
              else:
                  logData['completionErrorCount'] = 1
                  logData['completionErrors'] = str(GoogleLog)

      #Now that everything's done, note it in the log.
      logLines = []
      with open(r'HDScrapeLog.txt', 'r') as logFile:
          for line in logFile:
              logLines.append(line)
      lastLine = logLines[-1]
      todaysData = json.loads(lastLine)
      if todaysData['date'] != datetime.date.today().isoformat():
          errorTypes = ['HDErrorCount', 'GoogleErrorCount', 'completionErrorCount']
          errorTotal = 0
          for errorType in errorTypes:
              if errorType in todaysData:
                  errorTotal += todaysData[errorType]
          if errorTotal &gt; 0:
              needToMail = True
              mailMessage += str(errorTotal) + ' errors noted: ' + lastLine
          logLines.append('')
          lastLine = logLines[-1]
          todaysData = {'date': datetime.date.today().isoformat()}
      #Some bits in logData are counts, and are lists
      for bit in ['Unexceptional', 'HDErrorCount', 'GoogleErrorCount', 'changeCount', 'completionErrorCount']:
          if bit in logData:
              if bit in todaysData:
                  todaysData[bit] += 1
              else:
                  todaysData[bit] = 1
      for bit in ['HDErrors', 'GoogleErrors', 'changes', 'completionErrors']:
          if bit in logData:
              if bit in todaysData:
                  if logData[bit] not in todaysData[bit]:
                      todaysData[bit].append(logData[bit])
              else:
                  todaysData[bit] = [logData[bit]]
      lastLine = json.dumps(todaysData) + '\n'
      logLines[-1] = lastLine
      newFileString = ''.join(logLines)
      with open(r'C:\Users\Man\Dropbox\Coding\HDSceduleScrape\HDScrapeLog.txt', 'w') as logFile:
          logFile.write(newFileString)
      if needToMail:
          sendMail(mailMessage)

  if __name__ == '__main__':
      main()

        </code>
      </pre>
    </figure>
    </div>

  <div id="projectDisplay2" class="hiddenProject">
    <div><span>Title: </span><span>Viking</span></div>
    <div><span>Language: </span><span>Java</span></div>
    <div><span>Purpose: </span><span>An AI built to play Lux Delux, a computer game with rules similar to Risk.  Coauthored with John Torgerson.</span></div>
    <div><span>Description: </span><span>Has four major activity types: taking over a continent, knocking out an enemy's continent, taking random countries, and eliminating an opponent entirely.
      Develops a plan for nearly all activities that could be performed, and then scores them (basically gain over cost).  Chooses the highest scoring activities that it has the resources for and does them.
    Dynamically prioritizes enemies based on their relative strength.  Reassesses other objectives once it has committed to one (e.g. it tends to be cheaper to take over a continent if you have already breached it).</span></div>
    <figure>
        <pre>
<code>
  package com.sillysoft.lux.agent;

  import com.sillysoft.lux.*;
  import com.sillysoft.lux.util.*;
  import java.util.*;

  //
  //  Viking.java
  //
  //  Viking is written by John Torgerson and Jesse Halvorsen
  //


  public class Viking implements LuxAgent
  {
      // This agent's ownerCode:
      protected int ID;

      // Store some refs the board and to the country array
      protected Board board;
      protected Country[] countries;
      protected int numConts;

      // It might be useful to have a random number generator
      protected Random rand;

      // we'll need to calculate attack plans in the placeArmies phase and remember them during the attackPhase
      // so we'll store those plans in this variable
      protected ArrayList&lt;int[]&gt; battlePlan;

      // tells moveArmiesIn() to leave some of its armies behind
      // after successfully attacking a country. attackPhase() will calculate this number
      // so that moveArmiesIn() will know how many armies to leave behind
      protected int leaveArmies;

      // &lt;borderArmies&gt; will store the number of armies we want to put on a border country
      // &lt;idealBorderArmies&gt; will store the ideal number of armies a border country needs
      // key: country code
      // value: number of armies
      protected Map&lt;Integer, Integer&gt; borderArmies;
      protected Map&lt;Integer, Integer&gt; idealBorderArmies;

      // will contain int[] arrays of country codes, called &quot;areas&quot;
      // each area is based on a continent of the map, but may contain
      // extra countries outside of that continent to reduce the number of
      // borders to defend; therefore, some countries will be in
      // more than one area (but no area should have duplicates of any country)
      protected ArrayList&lt;int[]&gt; smartAreas;

      // used in findAreaPaths() when we find paths recursively by brute force
      // to keep track of how many we've found so far
      protected int pathCount;

      // the universal factor by which we multiply our gain from taking over countries
      // that we aren't protecting with a border; in other words, the expected likelihood
      // that we'll keep a country we take over but don't guard;
      // we use this value to help score landgrabs and other paths that aren't part of takeover areas
      protected float unguardedKeepChance;

      // for teaming purposes, this will be a list of all players we are allied with
      // by default, we will team with other Vikings
      protected ArrayList&lt;Integer&gt; allies;

      // a flag to remember if this is the first loop through placeInitialArmies at the beginning of the game,
      protected boolean firstPlacement;

      public Viking()
      {
          rand = new Random();
          battlePlan = new ArrayList&lt;int[]&gt;();
          borderArmies = new HashMap&lt;Integer, Integer&gt;();
          idealBorderArmies = new HashMap&lt;Integer, Integer&gt;();
          smartAreas = new ArrayList&lt;int[]&gt;();
          allies = new ArrayList&lt;Integer&gt;();
          firstPlacement = true;
      }

      // Save references
      public void setPrefs( int newID, Board theboard )
      {
          ID = newID;		// this is how we distinguish what countries we own

          board = theboard;
          countries = board.getCountries();
          numConts = board.getNumberOfContinents();
          smartAreas = calculateSmartAreas();
          pathCount = 0;
          unguardedKeepChance = 1.0f / 3.0f;
      }

      public String name()
      {
          return &quot;Viking&quot;;
      }

      public float version()
      {
          return 1.0f;
      }

      public String description()
      {
          return &quot;Viking is a bot&quot;;
      }

      protected void testChat(String topic, String message) {
          String[] topics = {
  //            &quot;placeInitialArmies&quot;,
              &quot;placeArmies&quot;,
  //            &quot;attackPhase&quot;,
  //            &quot;moveArmiesIn&quot;,
  //            &quot;fortifyPhase&quot;,
  //            &quot;message&quot;,

  //            &quot;continentFitness&quot;,
  //            &quot;getAreaTakeoverPaths&quot;,
  //            &quot;findAreaPaths&quot;,
  //            &quot;pickBestTakeoverPaths&quot;,
  //            &quot;getCheapestRouteToArea&quot;,
  //            &quot;placeArmiesOnRoutes&quot;,
  //            &quot;calculateCladeCost&quot;,
  //            &quot;calculateBorderStrength&quot;,
  //            &quot;calculateIdealBorderStrength&quot;,
  //            &quot;getAreaBonuses&quot;,
  //            &quot;calculateLandgrabObjective&quot;,
  //            &quot;findWeakestNeighborOwnedByStrongestEnemy&quot;,
  //            &quot;findWeakestNeighborWithMostEnemyNeighbors&quot;,
  //            &quot;getSmartBordersArea&quot;,
  //            &quot;calculateWipeoutObjective&quot;,
  //            &quot;findContiguousAreas&quot;,
  //            &quot;calculateTakeoverObjective&quot;,
              &quot;&quot;
          };

          for (int i=0; i&lt;topics.length; i++) {
              if (topic == topics[i]) {
                  board.sendChat(message);
                  //System.out.println(message);
              }
          }
      }

      // pick initial countries at the beginning of the game. We will do this later.
      public int pickCountry() {
          return -1;
      }

      // place initial armies at the beginning of the game
      public void placeInitialArmies( int numberOfArmies ) {
          testChat(&quot;placeInitialArmies&quot;, &quot;*********** PLACE INITIAL ARMIES ***********&quot;);

          // only on the first time we place initial armies, we want to turn teaming with other Vikings on
          // we want teaming on by default, but we don't want to do it every time we place initial armies,
          // because then it will announce it every time
          if (firstPlacement) {
            teamingOn(); // turn teaming on with other Vikings by default
            firstPlacement = false;
          }

          // simply call placeArmies(), but we pass 'true' as the second parameter
          // to tell it that we're calling it from placeInitialArmies(), because a few
          // things need to be handled differently when we're placing armies at the
          // beginning of the game
          placeArmies(numberOfArmies, true);
      }

      public void cardsPhase( Card[] cards ) {
      }

      // place armies at the beginning of each turn
      // we've created an overloaded version of placeArmies() that takes an additional boolean parameter
      // this simply tells us whether it was called by placeInitialArmies() or not;
      // this is useful because there are a few behaviors that need to be different in that case
      public void placeArmies(int numberOfArmies, boolean initial) {
          testChat(&quot;placeArmies&quot;,
                   &quot;\n**********************************************&quot; +
                   &quot;\n**********************************************&quot; +
                   &quot;\n**************** PLACE ARMIES ****************&quot; +
                   &quot;\n**********************************************&quot; +
                   &quot;\n**********************************************&quot; +
                   &quot;\n Turn: &quot; + board.getTurnCount() + &quot; - Our income: &quot; + board.getPlayerIncome(ID) + &quot; - Total enemy income: &quot; + getTotalEnemyIncome());

          int playersLeft = board.getNumberOfPlayersLeft();
          for (int i=0; i&lt;playersLeft; i++) {
            if (isAlly(i)) {
              testChat(&quot;placeArmies&quot;, &quot;Player &quot; + board.getPlayerName(i) + &quot; is in allies.&quot;);
            }
            else {
              testChat(&quot;placeArmies&quot;, &quot;Player &quot; + board.getPlayerName(i) + &quot; is not in allies.&quot;);
            }
          }


          //&nbsp;the &lt;initial&gt; boolean is a flag that tells us if this function
          // was called from placeInitialArmies(); we want to clear &lt;battlePlan&gt;
          // every turn, but we don't want to clear it in between placeInitialArmies()
          // calls at the beginning of the game (or before the first turn);
          // &lt;battlePlan&gt; is emptied each turn one path at a time in attackPhase(),
          // so normally it will already be empty here; however, we have to clear it anyway
          // for the special case that placeArmies() was called in the middle of a turn,
          // which happens when we wipeout an enemy and get to cash cards mid-turn;
          // in that case, we want to create a new &lt;battlePlan&gt; from scratch, erasing the old one
          // that attackPhase() is in the middle of, and letting it do the new one instead
          if (initial == false &amp;&amp; board.getTurnCount() &gt; 1) {
              battlePlan.clear();
          }

          // reset the global &lt;borderArmies&gt; HashMap, which stores the border garrison strength for each border country of each area we want to take over
          // instead of completely clearing it from the previous turn, we want to set each entry to the number of armies
          // that are actually on that country (and if we don't own the country anymore, remove it from the hashmap);
          // the reason for doing this is so we can keep those armies reserved so they aren't used for anything else,
          // even if we don't pick the takeover objective that uses these borders this particular turn;
          // so why set them to the number of extant armies instead of just leaving the value set to the ideal border strength
          // for that country as they were last turn? because we don't want to have to sink more armies into this country
          // if we don't need to (which could otherwise happen if another objective had to interact with this country);
          // if a takeover objective IS picked this turn that uses any of these countries as a border, it will simply overwrite
          // that value in the hashmap with whatever it wants to put there as a border;
          // the values we're setting here only matter if we don't pick that objective this turn;
          if (initial == false &amp;&amp; board.getTurnCount() &gt; 1) {
              resetBorderArmies();
          }

          // this array list will hold all of the possible objectives we can pursue this turn
          ArrayList&lt;HashMap&gt; objectiveList = new ArrayList&lt;HashMap&gt;();

          // find and add list of objectives to knockout enemy bonuses
          objectiveList.addAll(findKnockoutObjectives());

          // find and add list of continent takeover objectives
          objectiveList.addAll(findTakeoverObjectives());

          // create and add landgrab objective
          objectiveList.add(calculateLandgrabObjective(numberOfArmies));

          // find and add wipeout objectives
          ArrayList&lt;HashMap&gt; tempWipeouts = findWipeoutObjectives();
          chatObjectives(&quot;placeArmies&quot;,tempWipeouts);
          objectiveList.addAll(tempWipeouts);

          // sort all the objectives by score
          sortObjectives(objectiveList, &quot;score&quot;);

          // display a summary of each objective for debugging purposes
          testChat(&quot;placeArmies&quot;, &quot;--- &quot; + objectiveList.size() + &quot; Possible Objectives: ---&quot;);
          for (HashMap objective : objectiveList) {
              String summary = &quot;&quot;;
              if (objective != null) {
                  summary = (String) objective.get(&quot;summary&quot;);
              } else {
                  summary = &quot;[null objective]&quot;;
              }
              testChat(&quot;placeArmies&quot;, summary);
          }
          testChat(&quot;placeArmies&quot;, &quot;****** Objectives we're choosing: ******&quot;);

          // loop through all objectives in order of score
          // picking as many as we can until we're out of armies
          // and placing armies on the appropriate routes as we go
          while (numberOfArmies &gt; 0 &amp;&amp; objectiveList.size() &gt; 0) {
              // some stuff for debugging
  //            testChat(&quot;placeArmies&quot;, &quot;~~~~~~~~~~~ LOOP ~~~~~~~~~~~ (Armies Left: &quot; + numberOfArmies + &quot;)&quot;);
              int testTemp = numberOfArmies;
              String chatString = &quot;&quot;;

              // set the &lt;picked&gt; flag to false until we've picked an objective
              boolean picked = false;

              // the first objective in the sorted list is the objective with the highest score;
              // we'll pick this objective (except in the special case that it's a knockout objective
              // that costs more than we can afford in a single turn)
              HashMap&lt;String, Object&gt; objective = objectiveList.get(0);

              if (objective != null) {
                  // store the type of the objective (whether it's a knockout or takeover, etc.)
                  String type = &quot;&quot;;
                  if (objective.containsKey(&quot;type&quot;)) {
                      type = (String) objective.get(&quot;type&quot;);
                  }

                  // if the objective is a knockout
                  if (type == &quot;knockout&quot;) {
                      // pick this objective if we can afford it
                      // (or if we're in the placeInitialArmies() phase, we can pick it even if we can't afford it)
                      if ((Integer) objective.get(&quot;cost&quot;) &lt;= numberOfArmies || initial == true) {
                          picked = true; // set &lt;picked&gt; flag to true

                          // add the knockout path to battlePlan
                          ArrayList&lt;int[]&gt; objectivePlan = (ArrayList&lt;int[]&gt;) objective.get(&quot;plan&quot;);
                          battlePlan.addAll(objectivePlan);
                      } else {
                          // if the knockout is too expensive, put it in the back
                          // we will then run the loop again without reassessing the objectives.
                          objectiveList.remove(0);
                          objectiveList.add(objective);
                      }
                  }
                  // if the objective is a takeover
                  else if (type == &quot;takeover&quot;) {
                      picked = true;

                      // we need to pick the right countries to place our armies on in order to take over the area
                      // the pickBestTakeoverPaths function will simulate taking over the area
                      // from multiple countries and give us back the best set of paths to do so
                      int[] takeoverArea = (int[]) objective.get(&quot;area&quot;);
                      ArrayList&lt;int[]&gt; takeoverPlan = pickBestTakeoverPaths(takeoverArea); // get the best paths to take over the goalCont

                      // add the takeover plan paths to &lt;battlePlan&gt;
                      battlePlan.addAll(takeoverPlan);

                      // calculate and store the desired border garrisons on the area we're taking over
                      // so that when we place the armies on battlePlan, it will know how many extra to place for the garrisons
                      setBorderStrength(takeoverArea);
                  }
                  // if the objective is a landgrab
                  else if (type == &quot;landgrab&quot;) {
                      picked = true; // set &lt;picked&gt; flag to true

                      // add the knockout path to battlePlan
                      ArrayList&lt;int[]&gt; objectivePlan = (ArrayList&lt;int[]&gt;) objective.get(&quot;plan&quot;);
                      battlePlan.addAll(objectivePlan);
                  }
                  // if the objective is a wipeout
                  else if (type == &quot;wipeout&quot;) {
                      picked = true; // set &lt;picked&gt; flag to true

                      // find the best paths to takeover all of the player's countries
                      int[] wipeoutArea = (int[]) objective.get(&quot;area&quot;);
                      ArrayList&lt;int[]&gt; wipeoutPlan = pickBestTakeoverPaths(wipeoutArea); // get the best paths to take over all the player's countries

                      // add those paths to battlePlan
                      battlePlan.addAll(wipeoutPlan);
                  }
                  // if we got here, we don't know what this objective is, so get rid of it
                  else {
                      objectiveList.remove(0);
                      testChat(&quot;placeArmies&quot;,&quot;[ERROR: UNKNOWN OBJECTIVE TYPE]&quot;);
                  }

                  // if we picked an objective this loop
                  // place armies on its routes, then remove it from the list
                  // and recalculate all the remaining objectives in case the one we picked affects them in any way
                  // and the sort the recalculated list
                  if (picked) {
                      // place the number of armies needed to fulfull the objective on the starting countries of all the paths
                      // store any remaining armies available in numberOfArmies
                      numberOfArmies = placeArmiesOnRoutes(battlePlan,numberOfArmies);

                      testTemp = testTemp - numberOfArmies;
                      testChat(&quot;placeArmies&quot;, (String) objective.get(&quot;summary&quot;) + &quot;, placed &quot; + testTemp + &quot; armies&quot;);

                      // since we've made plans for this objective, we don't need to look at it again
                      // except in the case of the landgrab objective, which we want to keep and recalculate each loop even if we picked it
                      if (type != &quot;landgrab&quot;) {
                          objectiveList.remove(0);
                      }

                      // loop through the list of remaining objectives
                      // and recalculate them all
                      for (int i=0; i&lt;objectiveList.size(); i++) {
                          HashMap&lt;String, Object&gt; element = objectiveList.get(i);
                          HashMap&lt;String, Object&gt; newElement = new HashMap&lt;String, Object&gt;(); // instantiate HashMap for recalculated objective, regardless of type

                          // each type uses its own creation function
                          String elementType = &quot;&quot;;
                          if (element != null &amp;&amp; element.containsKey(&quot;type&quot;)) {
                              elementType = (String) element.get(&quot;type&quot;);
                          }
                          if (elementType == &quot;knockout&quot;) {
                              newElement = calculateKnockoutObjective((Integer) element.get(&quot;continentID&quot;));  // knockouts are generated based off of continent IDs
                          } else if (elementType == &quot;takeover&quot;) {
                              newElement = calculateTakeoverObjective((int[]) element.get(&quot;area&quot;));  // takeovers are generated based on areas
                          } else if (elementType == &quot;landgrab&quot;) {
                              newElement = calculateLandgrabObjective(numberOfArmies); // the landgrab is generated by a number of armies it's allowed to use; in this case, we give it all the remaining armies we have
                          } else if (elementType == &quot;wipeout&quot;) {
                              newElement = calculateWipeoutObjective((Integer) element.get(&quot;playerID&quot;)); // recalculate wipeout objective by passing the player ID
                          }
                          if (newElement != null &amp;&amp; !newElement.isEmpty()) { // if the recalculated objective isn't empty or null
                              objectiveList.set(i, newElement); // replace the old one with it
                          } else { // otherwise the element is null (e.g. if the knockout continent is/will be no longer owned by an enemy; i.e. we picked a path through it)
                              objectiveList.remove(i); // remove it from the list
                              i--; // decrement i, because all the elements moved to the left (I know, I know)
                          }
                      }

                      // re-sort the list
                      sortObjectives(objectiveList, &quot;score&quot;);
                  }
              } else { // this objective doesn't exist
                  objectiveList.remove(0); // so remove it and move on to the next one
  //                testChat(&quot;placeArmies&quot;, &quot;[null objective]&quot;);
              }
          }
          if (numberOfArmies &gt; 0) {
              testChat(&quot;placeArmies&quot;,&quot;Viking: We've ended placement, but we still have armies......what a schmuck.&quot;);
              testChat(&quot;placeArmies&quot;,&quot;        number of armies: &quot; + numberOfArmies + &quot;, objectives left: &quot; + objectiveList.size());
          }

  //        testChat(&quot;placeArmies&quot;,&quot;--- BATTLE PLAN: ---&quot;);
  //        chatCountryNames(&quot;placeArmies&quot;,battlePlan);
      }
      public void placeArmies(int numberOfArmies) {
          placeArmies(numberOfArmies, false);
      }

      // attack!
      public void attackPhase() {
          // first some testing/debugging messages
          testChat(&quot;attackPhase&quot;, &quot;*********** ATTACK PHASE ***********&quot;);
          testChat(&quot;attackPhase&quot;, &quot;Attack Routes:&quot;);
          ArrayList&lt;int[]&gt; displayPlan = new ArrayList&lt;int[]&gt;();
          for (int[] route : battlePlan) {
              if (route.length &gt; 1) {
                  displayPlan.add(route);
              }
          }
          chatCountryNames(&quot;attackPhase&quot;,displayPlan);

          // loop through battlePlan (calculated in the placeArmies() phase),
          // which contains multiple attack routes, and execute each one
          //for (int i=0; i&lt;battlePlan.size(); i++) {
          while (battlePlan.size() &gt; 0) {
  //            testChat(&quot;attackPhase&quot;, &quot;------- Attack route: -------&quot;);
  //            chatCountryNames(&quot;attackPhase&quot;, battlePlan.get(i));

              // store the first route in the plan
              int[] attackRoute = battlePlan.get(0);

              // remove that route from the plan
              battlePlan.remove(0);

              if (countries[attackRoute[0]].getOwner() == ID) { // if we own the first country in the path

  //                testChat(&quot;attackPhase&quot;, &quot;First country on route has &quot; + countries[attackRoute[0]].getArmies() + &quot; armies.&quot;);

                  // loop through the whole route, attacking as we go
                  for(int j=0; j&lt;attackRoute.length-1; j++) {

  //                    testChat(&quot;attackPhase&quot;, &quot;Calculating forks from this country...&quot;);

                      // at each step of the path, before we actually attack
                      // we test for forks. if we find a branch point from this country
                      // then we have to tell moveArmiesIn() to leave some armies behind
                      // in order to take over the fork later from this point
                      int forkArmies = 0; // how many armies we want to leave behind to use for any forks from this country
                      for (int k=0; k&lt;battlePlan.size(); k++) { // loop through only the rest of the battlePlan paths (i.e. the ones we haven't attacked yet) to check for branch points
                          if (attackRoute[j] == battlePlan.get(k)[0]) {
                              forkArmies += calculateCladeCost(battlePlan, k); // calculate cost of any clades that fork from this point, and add them all to forkArmies
                          }
                      }

                      // find out if we want to leave any armies on this country as a border garrison
                      int garrisonArmies = checkBorderStrength(attackRoute[j]);

                      // leaveArmies is a global variable
                      // this is how many armies we want to leave on the attacking country
                      // both for forking from that country and to leave there as a border garrison
                      // moveArmiesIn() will use this variable to do that
                      leaveArmies = forkArmies + garrisonArmies;

                      // now we attack
                      if (countries[attackRoute[j]].getOwner() == ID &amp;&amp; countries[attackRoute[j]].getArmies() &gt; 1 &amp;&amp; countries[attackRoute[j+1]].getOwner() != ID) { // if we own the attacking country (and have &gt; 1 army in it) and we don't own the defending country
                          board.attack(attackRoute[j],attackRoute[j+1],true); // attack the next country in the route

                          // if we happen to have successfully attacked the last country owned by an enemy here, so that that enemy is now eliminated
                          // often we can cash cards mid-turn; when this happens, Lux will call placeArmies() again and then resume attackPhase() from this point;
                          // placeArmies() will replace &lt;battlePlan&gt; with a new one;
                          // in that case, the j-loop will continue executing our attack through &lt;attackRoute&gt;
                          // but on the next iteration of the while loop, the new &lt;battlePlan&gt; will be executed from the beginning, as desired;
                          // the only source of conflict is that we took over the rest of &lt;attackRoute&gt; in the j-loop before starting on the new &lt;battlePlan&gt;
                          // but if any routes in the new &lt;battlePlan&gt; overlap those countries, it should harmlessly iterate over them
                          // since we're checking for proper ownership of the attacking and defending countries here
                      } else {
                          testChat(&quot;attackPhase&quot;,&quot;Can't attack from &quot; + countries[attackRoute[j]].getName() + &quot; to &quot; + countries[attackRoute[j+1]].getName());
                      }
                  }
              }
          }

          // now we'll do army 'garbage collection'
          // i.e. find any leftover armies that aren't being used as a border garrison
          // and use them to attack any enemy neighbors they have

          // get all the countries we own
          ArrayList&lt;Integer&gt; ourCountries = new ArrayList&lt;Integer&gt;();
          for (Country country : countries) {
              if (country.getOwner() == ID) {
                  ourCountries.add(country.getCode());
              }
          }

          // loop through all the countries we own
          for (int country : ourCountries) {
              // only perform garbage collection on countries that are not in the &lt;borderArmies&gt; HashMap at all;
              // that way we leave any extra armies there might be on a border garrison
              // even when placeArmies() thinks they're superfluous this turn; we might want them there later
              if (!borderArmies.containsKey(country)) {
                  // the amount of extra armies on this country
                  int extraArmies = countries[country].getArmies() - 1;// - checkBorderStrength(country); // (don't need to check the border strength anymore since we're not garbage collecting on countries with border garrisons)
                  // if we have any extra armies to work with, we'll attack some enemies until we run out
                  if (extraArmies &gt; 0) {

                      testChat(&quot;attackPhase&quot;, &quot;Performing garbage collection on &quot; + getCountryName(country));

                      int attackingCountry = country;
                      while (extraArmies &gt; 0) { // attack another country on each loop until we run out of armies
                          int defendingCountry = findWeakestNeighborOwnedByStrongestEnemy(attackingCountry); // pick the best enemy neighbor to attack
                          if (defendingCountry == -1) { // if the above function returned -1, it didn't find any enemy neighbors
                              break; // so break the while loop, since we can't attack anyone
                          }
                          leaveArmies = checkBorderStrength(attackingCountry); // &lt;leaveArmies&gt; is a global variable that tells moveArmiesIn() how many armies to leave behind after an attack
                          board.attack(attackingCountry,defendingCountry,true); // attack the country we picked
                          if (countries[defendingCountry].getOwner() == ID) { // if we now own the country, then the attack was successful
                              extraArmies = countries[defendingCountry].getArmies() - 1;// - checkBorderStrength(defendingCountry); // reset &lt;extraArmies&gt; for new country (don't need to check the border strength anymore since we're not garbage collecting on countries with border garrisons)
                              attackingCountry = defendingCountry; // set the country we just conquered as the new attacking country
                          } else { // we ran out of armies before conquering the country
                              extraArmies = 0; // so we have zero armies left, and we're done
                          }
                      }
                  }
              }
          }
      }

      // decide how many armies to move upon a successful attack
      public int moveArmiesIn( int cca, int ccd)
      {
          // for now, we're always moving everything into the conquered country
          // unless the country we just attacked from is either a branch point for one or more forks
          // or is a border country that we want to leave some armies on as a garrison
          // in which case we will leave behind as many as we have calculated are necessary for both those purposes
          // and move the rest

          testChat(&quot;moveArmiesIn&quot;, &quot;*********** MOVE ARMIES IN ***********&quot;);

          int armiesOnFrom = countries[cca].getArmies() - 1; // number of armies on the country we just attacked from
          int amountToMove = Math.max(0, armiesOnFrom - leaveArmies); // move number of armies on the country minus leaveArmies

          testChat(&quot;moveArmiesIn&quot;, &quot;Attacking country: &quot; + countries[cca].getName() + &quot;\nArmies on attacking country after attacking (minus one): &quot; + armiesOnFrom + &quot;\nCost of forks/garrison: &quot; + leaveArmies + &quot;\nCountry to move into: &quot; + countries[ccd].getName() + &quot;\nAmount to move: &quot; + amountToMove);

          return amountToMove;
      }

      public void fortifyPhase() {
          testChat(&quot;fortifyPhase&quot;, &quot;*********** FORTIFY PHASE ***********&quot;);

          // first recalculate the border strengths of all the countries in &lt;borderArmies&gt;?

          // we will fortify in 2 phases:
          //
          // (1) if any exterior borders are touching each other, do some proportionalization between them
          //
          // (2) we move any unused armies either toward an exterior area border
          //     (but NOT toward any interior borders, i.e. borders that are boxed in by other areas we own)
          //     or toward the nearest country that neighbors an enemy country,
          //     whichever is better, as determined by distance vs. need

          // so first find and store the fitness of each exterior border;
          // an exterior border is a border of an area we (fully) own
          // that is not boxed in by other areas we (fully) own;
          // the fitness value stored for each exterior border in the hashmap
          // is its ideal strength / actual strength
          HashMap&lt;Integer,Double&gt; extBordersFitness = findAllExteriorBordersFitness();
          int[] extBorders = convertListToIntArray(extBordersFitness.keySet());

          // PHASE 1 - proportionalize between any groups of contiguous borders
          fortifyBetweenExteriorBorders(extBorders);

          // PHASE 2 - move any free armies on the board either to an exterior border or to the front
          fortifyFreeArmies(extBordersFitness);

      }

      // called when we win the game
      public String youWon()
      {
          // For variety we store a bunch of answers and pick one at random to return.
          String[] answers = new String[] {
              &quot;I won&quot;,
              &quot;beees?!&quot;
          };

          return answers[ rand.nextInt(answers.length) ];
      }

      public String message( String message, Object data )
      {
        // if somebody wrote something in the chat window
        if (message == &quot;chat&quot;) {
          Vector chatData = (Vector) data;
          // if it wasn't a Viking that chatted it
          if (!chatData.get(0).toString().equals(&quot;Viking (AI)&quot;)) {
            String text = (String) chatData.get(1);
            // for these commands, empty the list of allies to stop teaming with anyone
            if (text.equals(&quot;viking alone&quot;) || text.equals(&quot;viking team off&quot;)) {
              teamingOff();
            }
            if (text.equals(&quot;viking together&quot;) || text.equals(&quot;viking team on&quot;)) {
              teamingOn();
            }
          }
        }
        return null;
      }

      /*
       *   ********* HELPER / CUSTOM FUNCTIONS *********
       */

       // turn teaming on with other Vikings
      protected void teamingOn() {
        // populate &lt;allies&gt; with the names of all Viking players (except ourselves)
        int numPlayersLeft = board.getNumberOfPlayersLeft();
        for (int i=0; i&lt;numPlayersLeft; i++) {
          if (board.getAgentName(i) == &quot;Viking&quot; &amp;&amp; i != ID) { // if this player is a Viking and is not us
            allies.add(i); // add this Viking to allies
          }
        }
        // if we're the spokesperson, chat that teaming is on
        if (isSpokesperson()) board.sendChat(&quot;Viking is teaming with Viking&quot;);
      }

      // turn teaming off
      protected void teamingOff() {
        allies.clear(); // clear list of allies
        // if we're the spokesperson, chat that teaming is off
        if (isSpokesperson()) board.sendChat(&quot;Viking is no longer teaming&quot;);
      }

      // will loop through all players (not just players left) and choose one Viking to be the spokesperson
      // in cases where we want the Vikings to chat as a group; returns true if this Viking is the spokesperson
      protected boolean isSpokesperson() {
        // loop through all players (not just players left)
        int numPlayers = board.getNumberOfPlayers();
        for (int i=0; i&lt;numPlayers; i++) {
          if (board.getAgentName(i) == &quot;Viking&quot;) {
            if (i&lt;ID) {
              // then we aren't the Viking with the lowest ID, so we're not the spokesperson
              return false;
            }
          }
        }
        return true;
      }

      // called during fortify phase, evens out armies between exterior borders
      // that are touching each other
      protected void fortifyBetweenExteriorBorders(int[] extBorders) {
          testChat(&quot;fortifyPhase&quot;,&quot;=== PHASE 1: proportionalize contiguous borders ===&quot;);

          // find out if any group of exterior borders touch each other
          ArrayList&lt;int[]&gt; clumpedExtBorders = findContiguousAreas(extBorders);

          // loop through each clump of borders, and (if any clump is bigger than 1 country)
          // fortify armies between them such that they all have the same percentage of the
          // strength that they are supposed to be (as stored in &lt;borderArmies&gt;)
          for (int[] clump : clumpedExtBorders) {
              if (clump.length &gt; 1) { // if this clump is longer than one, then we have a group of borders that are contiguous with each other


                  // first, find the percentage of desired border strength that we're shooting for
                  // given the total number of armies we have to work with in this clump;
                  // this percentage will be the same for every country in this clump;
                  // that way, we can even things out between the countries in proportion to their need
                  int totalClumpArmies = 0; // total number of armies actually on this clump
                  int totalDesiredArmies = 0; // total number of armies in &lt;borderArmies&gt; for every country in this clump
                  for (int country : clump) {
                      totalClumpArmies += countries[country].getArmies() - 1;
                      totalDesiredArmies += borderArmies.get(country);
                  }
                  double plannedPercent = (double) totalClumpArmies / (double) totalDesiredArmies; // the percentage of &lt;borderArmies&gt; value we want to even each country out to

                  testChat(&quot;fortifyPhase&quot;,&quot;Each country in this clump: ----------------&quot;);

                  // now we'll find and store the difference between the actual number of armies on each country
                  // and the number of armies we're shooting for on each country (the calculated percentage of its &lt;borderArmies&gt; value);
                  // we'll call this value the &quot;offset&quot; of each country, and the rest of this function will
                  // do its best to move armies around to make every country's offset as close to 0 as possible
                  HashMap&lt;Integer, Integer&gt; armyOffset = new HashMap&lt;Integer, Integer&gt;();
                  for (int country : clump) {
                      int plannedArmies = (int) Math.floor(plannedPercent * (double) borderArmies.get(country));
                      armyOffset.put(country, countries[country].getArmies() - 1 - plannedArmies);

                      testChat(&quot;fortifyPhase&quot;,getCountryName(country) + &quot; offset: &quot; + armyOffset.get(country) + &quot; - shooting for: &quot; + plannedArmies + &quot; - (actual armies: &quot; + (countries[country].getArmies()-1) + &quot;, borderArmies: &quot; + borderArmies.get(country) + &quot;)&quot;);
                  }

                  testChat(&quot;fortifyPhase&quot;,&quot;--------------------------------------------&quot;);

                  // a flag for the upcoming loop that tells us if we've moved any armies
                  boolean moved = true;

                  // so now we have a hashmap containing the offsets of all the countries in the clump
                  // (a measure of how many armies they need to get up to their proper proportion of the available armies);
                  // so next we'll loop through the clump and even out each country with each of its neighbors
                  // as many times as we can while we still have armies to move around;
                  // when we can't move any more armies, or everything is even, we're done
                  while (moved) {
                      // set flag to false
                      moved = false;

                      // sort the clump in ascending order of offset so the neediest countries are first
                      for (int i=1; i&lt;clump.length; i++) {
                          int sortElement = clump[i];
                          int sortValue = armyOffset.get(sortElement);
                          int j;
                          for(j=i; j&gt;0 &amp;&amp; armyOffset.get(clump[j - 1])&gt;sortValue; j--) {
                              clump[j] = clump[j - 1];
                          }
                          clump[j] = sortElement;
                      }

                      testChat(&quot;fortifyPhase&quot;,&quot;---### loop through clump ###---&quot;);

                      // now loop through the clump once and equalize each country's offsets (starting with the neediest country)
                      // with all of its neighbors one at a time (starting with the richest neighbor)
                      for (int country : clump) {

                          testChat(&quot;fortifyPhase&quot;,&quot;Checking &quot; + getCountryName(country) + &quot;...&quot;);

                          // get list of &lt;country&gt;'s neighbors that are in the clump
                          int[] allNeighbors = countries[country].getAdjoiningCodeList(); // all neighbors of &lt;country&gt;
                          ArrayList&lt;Integer&gt; neighbors = new ArrayList&lt;Integer&gt;();
                          for (int neighbor : allNeighbors) { // loop through neighbors
                              // if this neighbor is one of the exterior borders in this clump
                              if (armyOffset.containsKey(neighbor)) {
                                  neighbors.add(neighbor); // add it to the list
                              }
                          }

                          // sort the list of neighbors so the richest ones are first
                          for (int i=1; i&lt;neighbors.size(); i++) {
                              int sortValue = armyOffset.get(neighbors.get(i));
                              int j;
                              for (j=i; j&gt;0 &amp;&amp; armyOffset.get(neighbors.get(j-1))&lt;sortValue; j--) {
                              }
                              neighbors.add(j,neighbors.remove(i));
                          }

                          // now loop through the neighbors and equalize with each of them one at a time
                          for (int neighbor : neighbors) {
                              // only move armies if the difference between the two countries' offsets is more than 1
                              if (Math.abs(armyOffset.get(country) - armyOffset.get(neighbor)) &gt; 1) {
                                  // we might be giving armies to the neighbor or taking them from the neighbor
                                  // so we need to abstract those possibilities into two variables, &lt;fromCountry&gt; and &lt;toCountry&gt;,
                                  // which could be either &lt;country&gt; or &lt;neighbor&gt;, depending on which is richer/poorer than the other;
                                  // so &lt;fromCountry&gt; is the one with the higher offset, and &lt;toCountry&gt; is the one with the lower offset
                                  int fromCountry = armyOffset.get(country) &gt; armyOffset.get(neighbor) ? country : neighbor;
                                  int toCountry = armyOffset.get(country) &gt; armyOffset.get(neighbor) ? neighbor : country;

                                  // the amount to move is the difference between the two countries' offsets, divided by two, rounded down
                                  // (we just use integer division to round down)
                                  // (by rounding down, we're conservative and don't move the remainder when we have an uneven amount to divide)
                                  // if this amount is more than the armies which can be moved, then just move as many as we can
                                  int moveAmount = Math.min((armyOffset.get(fromCountry) - armyOffset.get(toCountry))/2, getRealMoveableArmies(fromCountry));

                                  // if there are any armies to move (and for safety, we check that we own both countries)
                                  if (moveAmount &gt; 0 &amp;&amp; countries[fromCountry].getOwner() == ID &amp;&amp; countries[toCountry].getOwner() == ID) {
                                      // move the armies
                                      board.fortifyArmies(moveAmount, fromCountry, toCountry);

                                      testChat(&quot;fortifyPhase&quot;,&quot;     ...moving &quot; + moveAmount + &quot; from &quot; + getCountryName(fromCountry) + &quot; (offset: &quot; + armyOffset.get(fromCountry) + &quot;) to &quot; + getCountryName(toCountry) + &quot; (offset: &quot; + armyOffset.get(toCountry) + &quot;)&quot;);

                                      // subtract the armies we moved from the offset for &lt;fromCountry&gt;
                                      armyOffset.put(fromCountry, armyOffset.get(fromCountry) - moveAmount);

                                      // add the armies we moved to the offset for &lt;toCountry&gt;
                                      armyOffset.put(toCountry, armyOffset.get(toCountry) + moveAmount);

                                      // set the &lt;moved&gt; flag to true
                                      moved = true;
                                  }
                              } // end if difference is &gt; 1
                          } // end loop through neighbors of this country
                      } // end loop through this clump
                  } // end while(moved)

                  testChat(&quot;fortifyPhase&quot;,&quot;-- Results for this clump: --&quot;);
                  for (int country : clump) {
                      int plannedArmies = countries[country].getArmies() - 1 - armyOffset.get(country);
                      testChat(&quot;fortifyPhase&quot;,getCountryName(country) + &quot; offset: &quot; + armyOffset.get(country) + &quot; - shooting for: &quot; + plannedArmies + &quot; - (actual armies: &quot; + (countries[country].getArmies()-1) + &quot;, borderArmies: &quot; + borderArmies.get(country) + &quot;)&quot;);
                  }

              } // end if clump is longer than 1 country
          } // end for-loop through clumps
      } // end fortifyBetweenExteriorBorders()

      // called during fortify phase, moves any free armies either toward an exterior border
      // or toward the nearest country that touches an enemy
      protected void fortifyFreeArmies(HashMap&lt;Integer,Double&gt; extBordersFitness) {
          testChat(&quot;fortifyPhase&quot;,&quot;=== PHASE 2: move free armies toward borders or the front ===&quot;);

          // create array of exterior borders
          int[] extBorders = convertListToIntArray(extBordersFitness.keySet());

          // loop through all the countries we own
          // and move any free armies we find (that aren't on an exterior border)
          // either toward an exterior border or toward the closest country that neighbors an enemy
          testChat(&quot;fortifyPhase&quot;, &quot;Countries we can move from: &quot;);
          CountryIterator ourCountries = new PlayerIterator(ID, countries);
          while (ourCountries.hasNext()) {
              int country = ourCountries.next().getCode();

              // see if this country has any free armies
              int freeArmies = countries[country].getArmies() - 1 - checkIdealBorderStrength(country);

              // if this country has free armies and is not itself an exterior border
              // then we want to free move armies from this country to somewhere
              if (freeArmies &gt; 0 &amp;&amp; !extBordersFitness.containsKey(country)) {

                  testChat(&quot;fortifyPhase&quot;, &quot;== possible paths to fortify from &quot; + countries[country].getName() + &quot; ==&quot;);

                  // there are two possible places we might want to send this country's free armies;
                  // the first is one of the exterior border countries, and the second is the nearest
                  // country that touches an enemy country; we'll calculate a score for each possible
                  // destination out of those possibilities and send the armies to the country
                  // with the highest score

                  double score = 0.0d;
                  double highestScore = 0.0d;

                  // first, we'll find the nearest country that touches an enemy country
                  // and score that path appropriately ( 1 / path length^2 )
                  int[] pickedPath = pathToNearestCountryWithEnemyNeighbor(country);
                  if (pickedPath == null) { // if the function returned null
                      // that means it didn't find any enemies anywhere on the board for some reason;
                      // that should probably never happen, but if it does, we'll set &lt;pickedPath&gt;
                      // to a single-element length array containing just &lt;country&gt;
                      pickedPath = new int[]{country};
                  }
                  if (!extBordersFitness.containsKey(pickedPath[pickedPath.length-1])) {
                      // score this path, as long as the destination country (last country in the path) isn't an exterior border
                      // (if it is an exterior border, we'll leave the score at the default 0, so it will be ignored,
                      // because in that case we'll already be considering that path when we look at all the exterior borders)
                      highestScore = 1d / Math.pow((double) pickedPath.length, 2); // score is 1 / path length^2
                  }

                  testChat(&quot;fortifyPhase&quot;,Arrays.toString(getCountryNames(pickedPath)) + &quot; - &quot; + highestScore + &quot; - front lines&quot;);

                  // now loop through all exterior borders and find paths to them,
                  // scoring them by ( ideal strength / (actual strength * path length^2) )
                  // and pick the highest overall score
                  for (int border : extBorders) {
                      // get a path to the next exterior border and calculate its score
                      int[] candidatePath = BoardHelper.friendlyPathBetweenCountries(country, border, countries);
                      if (candidatePath != null) {
                          score = (double) extBordersFitness.get(border) / Math.pow((double) candidatePath.length, 2);

                          testChat(&quot;fortifyPhase&quot;,Arrays.toString(getCountryNames(candidatePath)) + &quot; - &quot; + score);

                          // if this path has the highest score, pick it
                          if (score &gt; highestScore) {
                              pickedPath = candidatePath;
                              highestScore = score;
                          }
                      }
                  }

                  testChat(&quot;fortifyPhase&quot;, &quot;Path we're picking: &quot; + Arrays.toString(getCountryNames(pickedPath)));

                  // fortify the armies along the path with the highest score
                  for (int i=0; i&lt;pickedPath.length-1; i++) {
                      int fromCountry = pickedPath[i];
                      int toCountry = pickedPath[i+1];

                      // figure out how many armies to move from this country:
                      // excess armies (above ideal border strength) or moveable armies, whichever is smaller
                      freeArmies = countries[fromCountry].getArmies() - 1 - checkIdealBorderStrength(fromCountry);
                      int moveArmies = Math.min(freeArmies, countries[fromCountry].getMoveableArmies());

                      // do the actual free move,
                      // as long as the amount we can move is greater than 0 and we own both countries
                      if (moveArmies &gt; 0 &amp;&amp; countries[fromCountry].getOwner() == ID &amp;&amp; countries[toCountry].getOwner() == ID) {
                          board.fortifyArmies(moveArmies, fromCountry, toCountry);
                      } else {
                          // otherwise we can't move anything anymore, so stop looping through the path
                          break;
                      }
                  }
              }
          }
      }

      // returns the number of actual armies on a country that can be fortified;
      // the &lt;countries&gt; method getMoveableArmies() isn't reliable
      // because it returns 1 for countries that only have 1 (bound) army on them,
      // which cannot actually be moved
      protected int getRealMoveableArmies(int country) {
          return Math.min(countries[country].getMoveableArmies(),countries[country].getArmies()-1);
      }

      // given a country &lt;startCountry&gt;, find and return a path (int[]) to the nearest country
      // that has a neighbor which is not owned by the owner of &lt;startCountry&gt;;
      // if &lt;startCountry&gt; itself has an enemy neighbor, will just return a path of length 1 containing only &lt;startCountry&gt;
      protected int[] pathToNearestCountryWithEnemyNeighbor(int startCountry) {
          // the owner of the starting country
          int owner = countries[startCountry].getOwner();

          // we'll store whether we've seen a country before in a boolean array
          // so we don't double count it
          boolean[] alreadySeen = new boolean[countries.length];
          for (int i=0; i&lt;countries.length; i++) {
              alreadySeen[i] = false;
          }

          // create a self-sorting stack &lt;Q&gt;, in which we'll store each path we create as we go along;
          // we'll loop around, on each loop picking the shortest path in the stack and finding the neighbors
          // of the last country in it, and adding them each to the end of their own new path,
          // which we'll add to the stack until we find one that's an enemy,
          // in which case we'll return the path leading up to it and we're done
          CountryPathStack Q = new CountryPathStack();
          int country = startCountry;
          int[] path = new int[1];
          path[0] = country;
          while (true) {
              // store this country as seen
              alreadySeen[country] = true;

              // get this country's neighbors and loop through them;
              // we'll test if any of them are an enemy country, and if they are, we're done;
              // if not, we'll add them each to the end of their own new path
              // and add all those paths to the stack
              int[] neighbors = countries[country].getAdjoiningCodeList();
              for (int neighbor : neighbors) {
                  if (alreadySeen[neighbor] == false) { // if we haven't already seen this country
                      // if this neighbor is an enemy, then &lt;country&gt; is the last country in the path, so we're done
                      if (countries[neighbor].getOwner() != owner) {
                          return path;
                      }

                      // otherwise, we need to keep searching
                      // so create a new path with this neighbor at the end of it
                      // and push it onto the stack
                      int[] newPath = new int[path.length+1];
                      System.arraycopy(path,0,newPath,0,path.length);
                      newPath[newPath.length-1] = neighbor;
                      Q.pushWithValueAndHistory(countries[neighbor], newPath.length, newPath);
                  }
              }

              // if the Q is empty, we couldn't find any enemy neighbors at all
              if (Q.isEmpty()) {
                  System.out.println(&quot;ERROR in pathToNearestCountryWithEnemyNeighbor(): can't find any enemy neighbors&quot;);
                  return null;
              }

              // pop the shortest path and its last country off of the stack for the next loop
              path = Q.topHistory();
              country = Q.pop();
          }
      }

      // returns a hashmap of all borders of all areas (that we fully own) that are not blocked in by another area we own
      //&nbsp;together with their 'fitness', which is simply their ideal strength divided by the number of armies actually on them
      protected HashMap&lt;Integer,Double&gt; findAllExteriorBordersFitness() {
          // the hashmap where we'll store the country codes and fitnesses of all the exterior borders
          HashMap&lt;Integer,Double&gt; extBordersFitness = new HashMap&lt;Integer,Double&gt;();

          // get list of all borders
          ArrayList&lt;Integer&gt; candidates = new ArrayList&lt;Integer&gt;(borderArmies.keySet());

          // loop through all borders and eliminate borders that are blocked in by an area that we completely own
          Iterator&lt;Integer&gt; iter = candidates.iterator();
          while (iter.hasNext()) {
              int border = iter.next(); // the border country we're checking

              // first check if the border itself is part of an area that we fully own;
              boolean validBorder = false;
              int areaIndex = -1;
              for (int i=0; i&lt;smartAreas.size(); i++) { // loop through all areas on the board
                  int[] area = smartAreas.get(i);
                  if (isInArray(border, area) &amp;&amp; playerOwnsArea(area)) { // if the border is in this area and we fully own this area
                      validBorder = true; // then the border is valid
                      areaIndex = i; // save the area that this is part of (we'll need this later to calculate its ideal strength)
                      break; // and we don't need to check the rest of the areas
                  }
              }

              // if the &lt;validBorder&gt; flag is true, then go ahead and check to see if it's exterior or not
              if (validBorder) {
                  int[] neighbors = countries[border].getAdjoiningCodeList(); // get this border's neighbors
                  boolean exteriorBorder = false;
                  for (int neighbor : neighbors) { // loop through all the neighbors
                      boolean externalNeighbor = true; // flag for whether this neighbor is part of at least one area that we completely own
                      for (int[] area : smartAreas) { // loop through all areas (&lt;smartAreas&gt; is a global list of all the areas on the board)
                          if (isInArray(neighbor, area) &amp;&amp; playerOwnsArea(area)) { // if this neighbor is in this area and we fully own this area
                              // if we're here, we know this neighbor is part of at least one area that we completely own
                              externalNeighbor = false; // so set the flag to false
                              break; // and we don't need to loop through the rest of the areas
                          }
                      }
                      // if the &lt;externalNeighbor&gt; flag is true, then this neighbor is not part of any areas that we completely own
                      // so we know that this border is an exterior border and we don't want to remove it
                      if (externalNeighbor) {
                          exteriorBorder = true; // set &lt;exteriorBorder&gt; flag to true
                          break; // we don't need to check the rest of its neighbors
                      }
                  }
                  // if this is an exterior border
                  // then find its fitness (ideal strength / actual armies)
                  // and add it to the hashmap
                  if (exteriorBorder == true) {

                      int ideal = calculateIdealBorderStrength(border, smartAreas.get(areaIndex));
                      int actual = countries[border].getArmies();
                      double fitness = ((double) ideal + 1d) / (double) actual;

                      // save the border and its fitness in the hashmap
                      extBordersFitness.put(border, fitness);
                  }
              }
          }

          // now the candidates list should only contain exterior borders
          // so convert it to an int[] array and return it
          return extBordersFitness;
      }

      // find the areas with smart borders that we'll use for the whole game;
      // each area is based on a continent of the map, but may contain
      // extra countries outside of that continent to reduce the number of
      // borders to defend; therefore, some countries will be in
      // more than one area (but no area should have duplicates of any country)
      protected ArrayList&lt;int[]&gt; calculateSmartAreas() {
          ArrayList&lt;int[]&gt; areas = new ArrayList&lt;int[]&gt;();

          // loop through all the continents to create an &quot;objective&quot; hashmap for each one and add it to objectiveList
          for(int continent = 0; continent &lt; numConts; continent++) {
              // get countries in this continent
              // plus possibly some extra countries outside the continent in order to
              // reduce the number of borders necessary to defend
              int[] area = getSmartBordersArea(getCountriesInContinent(continent));

              // add objective to objectiveList arraylist
              areas.add(area);
          }
          return areas;
      }

      // returns a list of wipeout objectives, one for each player remaining in the game that isn't us
      // a wipeout objective is a list of attack paths to eliminate a player from the game entirely
      // along with an accompanying score
      protected ArrayList&lt;HashMap&gt; findWipeoutObjectives() {
          // the list of objectives we'll return
          ArrayList&lt;HashMap&gt; objectiveList = new ArrayList&lt;HashMap&gt;();

          int totalPlayers = board.getNumberOfPlayers(); // the number of players that started the game

          // loop through all the players
          for (int player=0; player&lt;totalPlayers; player++) {
              // if the player isn't us and the player is still in the game
              if (player != ID &amp;&amp; BoardHelper.playerIsStillInTheGame(player, countries)) {
                  // then calculate a wipeout objective for this player
                  HashMap&lt;String,Object&gt; objective = calculateWipeoutObjective(player);

                  // if the objective was actually created for this player
                  if (objective != null) {
                      // add it to the list
                      objectiveList.add(objective);
                  }
              }
          }

          // return the list
          return objectiveList;
      }

      // calculates a wipeout objective for the given player
      protected HashMap&lt;String, Object&gt; calculateWipeoutObjective(int player) {
          // create the HashMap
          HashMap&lt;String, Object&gt; objective = new HashMap&lt;String, Object&gt;();

          // only actually create the objective if the player doesn't have more armies than we'll probably be able to take over in a single turn
          // we also only want to wipeout enemies, not allies
          if (BoardHelper.getPlayerArmies(player, countries) &lt; board.getPlayerIncome(ID) &amp;&amp; isEnemy(player)) {

              // set type
              objective.put(&quot;type&quot;, &quot;wipeout&quot;);

              // set player ID
              objective.put(&quot;playerID&quot;, player);

              // set player name
              String playerName = board.getPlayerName(player);
              objective.put(&quot;playerName&quot;, playerName);

              // find and set area
              int[] playerCountries = getPlayerCountries(player); // all countries owned by &lt;player&gt;
              objective.put(&quot;area&quot;, playerCountries);

              // estimate and set cost
              ArrayList&lt;int[]&gt; contiguousAreas = findContiguousAreas(playerCountries); // break up player's countries into contiguous areas to estimate their costs separately
              testChat(&quot;calculateWipeoutObjective&quot;,&quot;Countries owned by &quot; + playerName + &quot;: &quot;);
              chatCountryNames(&quot;calculateWipeoutObjective&quot;,contiguousAreas);
              Set&lt;Integer&gt; totalCountriesToTake = new HashSet&lt;Integer&gt;(); // will contain every country we mean to take over, including any entry paths we need; we're using a hashset to avoid duplicates
              for(int[] area : contiguousAreas) { // loop through all the contiguous areas
                  int[] entryPath = getCheapestRouteToArea(area, false); // find the cheapest path to this area; pass 'false' because we don't care about ending up at the weakest border of the area
                  for (int i=1; i&lt;entryPath.length - 1; i++) { // add entryPath to the set, except the first element (which is a country we own, so doesn't count toward cost) and the last element (which is a country in the area, so it will get added separately)
                      totalCountriesToTake.add(entryPath[i]);
                  }
                  for (int country : area) { // add the countries in the area into the set
                      totalCountriesToTake.add(country);
                  }
              }
              int[] totalCountriesToTakeArray = convertListToIntArray(totalCountriesToTake); // convert to array so we can use it in getGlobCost; this array now contains every country owned by &lt;player&gt; and every country we'll need to take over to get to them, with no duplicates
              int cost = getGlobCost(totalCountriesToTakeArray); // the total estimated cost of the objective
              testChat(&quot;calculateWipeoutObjective&quot;,&quot;Countries with entry paths: &quot; + Arrays.toString(getCountryNames(totalCountriesToTakeArray)));
              objective.put(&quot;cost&quot;, cost);

              // calculate and set score
              float cardsValue = ((float) board.getPlayerCards(player) / 3.0f) * (float) board.getNextCardSetValue();  //(each card is treated as 1/3 the value of the next card set)
              float gain = unguardedKeepChance * (float) totalCountriesToTake.size() / 3.0f + cardsValue; // &lt;gain&gt; is the expected increase in our income: mainly the value of the cards we'll get, but also the number of countries we'll take over divided by 3, and then multiplied by &lt;unguardedKeepChance&gt; (a global, arbitrary reduction to account for the probability that we won't keep these countries)
              float enemyLoss = 0.0f; // &lt;enemyLoss&gt; is how much we reduce the bonus of any enemies we travel through, weighted by their relative income
              for (int country : totalCountriesToTake) { // loop through each enemy country in the (path and) area
                  enemyLoss += board.getPlayerIncome(countries[country].getOwner()); // add the income of the owner of each country
              }
              enemyLoss /= (3 * getTotalEnemyIncome() + 0.00001f); // divide the total by 3, because every 3 countries is worth 1 income point, and divide by total enemy income and add a tiny fudge just in case &lt;totalEnemyIncome&gt; is 0
              enemyLoss += cardsValue;
              float score = 10f * ((float) gain + enemyLoss) / ((float) cost + 0.00001f); // the score is our gain + the enemies' loss divided by cost and the square root of the number of turns it will take (to discourage large projects)
              objective.put(&quot;score&quot;, score);

              // create and set summary string (this is just useful for debugging)
              String summary = &quot;wipeout   - score: &quot;;
              String scoreStr = &quot;&quot; + score;
              summary += scoreStr.length() &gt;= 6 ? scoreStr.substring(0, 6) : scoreStr;
              summary += &quot; - &quot; + playerName + &quot;, cost: &quot; + cost;
              objective.put(&quot;summary&quot;, summary);

              return objective;
          } else {
              return null;
          }
      }

      // the idea of a Landgrab objective is just to take over a bunch of countries,
      // not to take over a continent, just to increase the number of our countries
      // and decrease that of our enemies; this function takes a number of armies
      // and finds a path from one of our countries that would take over as many
      // countries as possible with those armies, balanced by doing as much damage as
      // possible to the strongest enemies (so it might take a shorter path if that one
      // does more damage to a very strong enemy than a longer one)
      protected HashMap&lt;String, Object&gt; calculateLandgrabObjective(int armies) {
          HashMap&lt;String, Object&gt; objective = new HashMap&lt;String, Object&gt;();
          int[] ourCountries = getPlayerCountries(); // get list of countries we own

          testChat(&quot;calculateLandgrabObjective&quot;, &quot;----- Calculate Landgrab Objective -----&quot;);

          // recursively find weakest (preferring those owned by strongest opponent) enemy neighbors from each country we own to make several paths
          ArrayList&lt;ArrayList &lt;Integer&gt;&gt; candidatePaths = new ArrayList&lt;ArrayList &lt;Integer&gt;&gt;();
          for (int ourCountry : ourCountries) {
  //            testChat(&quot;calculateLandgrabObjective&quot;, &quot;--- Picking neighbor of &quot; + getCountryName(ourCountry) + &quot;:&quot;);

              ArrayList&lt;Integer&gt; path = new ArrayList&lt;Integer&gt;(); // will contain the current path
              path.add(ourCountry); // initially add the start country to the path
              float armiesLeft = (float) armies;
              while (armiesLeft &gt;= 0) { // keep finding countries for the path as long as we have at least 1 army
                  int nextCountry = findWeakestNeighborWithMostEnemyNeighbors(path.get(path.size()-1), path); // find the next country in the path
                  if (nextCountry != -1) { // if the function returned an actual enemy neighbor
                      path.add(nextCountry); // add it to the path
                      armiesLeft -= (float) countries[nextCountry].getArmies() * 0.5f + 1f; // subtract the cost of taking over that neighbor from &lt;armiesLeft&gt;
                  } else { // otherwise there were no enemy neighbors,
                      break; //  so we're done with this path, even if we have armies left
                  }
              }
              // if the path is longer than 1, add the path to the list of candidates
              // if it's only 1 element long, the starting country didn't have any enemy neighbors at all, so we want to ignore it
              if (path.size() &gt; 1) {
                  candidatePaths.add(path);
              }
          }

          testChat(&quot;calculateLandgrabObjective&quot;, &quot;Candidate paths:&quot;);

          //
          // pick the best path
          // we loop through all the paths and calculate their score (our gain + enemy losses divided by actual cost)
          // and pick the path with the highest score
          //
          ArrayList&lt;Integer&gt; pickedPath = new ArrayList&lt;Integer&gt;(); // will contain the path we pick
          float highestScore = 0.0f; // the highest value (gain + enemy losses over cost) we've seen so far, as we loop through and check each path
          float oldHighestScore = 0.0f;
          int pickedPathCost = 0; // the cost of the path we'll pick
          // we want to prefer paths which run through less populated areas;
          // we'll do a rough approximation of that by calculating the enemy army density in each continent
          // and when we're choosing between candidate paths, we'll prefer paths in continents with fewer enemy armies per country;
          // so first we'll calculate the free army density of each continent (how many enemy armies above 1 there are per country)
          float[]continentDensity = new float[numConts]; // this array will hold the densities of all the continents on the board
          testChat(&quot;calculateLandgrabObjective&quot;, &quot;===Continent Army Densities===&quot;);
          for (int cont=0; cont&lt;numConts; cont++) { // loop through all the continents
              int[] foreignCountries = getForeignCountriesInContinent(ID, cont); // all the foreign countries in this continent
              int freeArmies = 0;
              for (int foreignCountry : foreignCountries) { // loop through the foreign countries
                  freeArmies += countries[foreignCountry].getArmies() - 1; // add up all the free armies
              }
              int numCountries = BoardHelper.getContinentSize(cont, countries); // the number of countries in this continent
              float freeArmyDensity = (float) freeArmies / (float) numCountries; // this continent's density is the number of free enemy armies / the total number of countries
              continentDensity[cont] = freeArmyDensity; // store the density in the array of all continents' densities
  //            testChat(&quot;calculateLandgrabObjective&quot;, board.getContinentName(cont) + &quot;: &quot; + freeArmyDensity);
          }
          // next, we'll adjust that density by adding the average density of all its neighboring continents divided by 2
          float[] adjustedContDensity = new float[numConts]; // this array will hold the adjusted densities for all the continents
          float highestAdjustedDensity = 0.0f; // will contain the highest adjusted density of all continents
          for (int cont=0; cont&lt;numConts; cont++) { // loop through the continents again
              int[] neighbors = getNeighboringContinents(cont); // an array of continents that have countries that can attack the continent
              float adjustedDensity = continentDensity[cont]; // start by assigning the continent's density to &lt;adjustedDensity&gt;
              for (int neighbor : neighbors) {
                  adjustedDensity += continentDensity[neighbor] / (neighbors.length * 2); // then add the average densities of all the neighbor continents divided by 2
              }
              adjustedContDensity[cont] = adjustedDensity; // put this continent's adjusted density into the array
              if (adjustedDensity &gt; highestAdjustedDensity) { // if this is the highest adjusted density we've seen so far
                  highestAdjustedDensity = adjustedDensity; // save it in &lt;highestAdjustedDensity&gt;
              }
  //            testChat(&quot;calculateLandgrabObjective&quot;, &quot;Neighbors of &quot; + board.getContinentName(cont) + &quot;: &quot; + Arrays.toString(getContinentNames(neighbors)));
              testChat(&quot;calculateLandgrabObjective&quot;, &quot;Adjusted density of &quot; + board.getContinentName(cont) + &quot;: &quot; + adjustedDensity);
          }
          testChat(&quot;calculateLandgrabObjective&quot;, &quot;highest adjusted density: &quot; + highestAdjustedDensity + &quot;\n&quot;);
          // now we'll calculate a score for each path, and pick the one with the best score
          // the score accounts for:
          //   (1) the number of countries we gain by taking it over
          //   (2) the number of countries our enemies will lose, adjusted so that we prefer to take countries from stronger enemies
          //   (3) the cost of taking over the path
          //   (4) the number of free enemy armies in nearby continents
          for (ArrayList&lt;Integer&gt; path : candidatePaths) { // loop through all candidate paths
              // first, calculate our gain and the enemy losses from taking over the path
              int length = path.size(); // the length of the path
              float enemyLoss = findEnemyLoss(path); // the loss to our enemies when we take over the countries in this path
              float alliedLoss = findAlliedLoss(path); //the loss to our enemies when we take over those same countries
              float gain = 0.0f; // the value of the countries we gain
              for (int i=1; i&lt;length; i++) { // loop through all the countries in this path except the first one (which we own)
                  if (highestAdjustedDensity &gt; 0) {
                      gain += 1.0f - adjustedContDensity[countries[path.get(i)].getContinent()] / highestAdjustedDensity; // this is the calculated value of each country designed to favor continents with fewer enemy armies around (value should be between 0.0 and 1.0)
                  } else { // if the highestAdjustedDensity is 0, then we just add 1 to gain (to avoid dividing by zero)
                      gain += 1.0f;
                  }
              }

              gain = unguardedKeepChance * gain / 3.0f; // divide the total gain by 3, because every 3 countries is worth 1 income point, and multiply by &lt;unguardedKeepChance&gt;, a global (arbitrary) value that accounts for the chance that we'll keep countries unprotected by border garrisons

              // then calculate the actual cost of taking over the path
              int cost = getPathCost(convertListToIntArray(path));

              // and the score
              float score = 10f * (gain + enemyLoss - alliedLoss) / ((float) cost + 0.00001f);

              // then compare this path's score to the highest we've seen so far
              // and if they are higher, tentatively choose this path (update &lt;pickedPath&gt;, &lt;pickedPathCost&gt; and &lt;highestScore&gt; to this path)
              if (score &gt; highestScore) {
                  highestScore = score;
                  pickedPath = path;
                  pickedPathCost = cost;
              }

              chatCountryNames(&quot;calculateLandgrabObjective&quot;, path);
              testChat(&quot;calculateLandgrabObjective&quot;, &quot;Player gain: &quot; + gain + &quot;, eloss: &quot; + enemyLoss + &quot;, aloss: &quot; + alliedLoss);
              testChat(&quot;calculateLandgrabObjective&quot;, &quot;score: &quot; + score + &quot;\n&quot;);
          }

          testChat(&quot;calculateLandgrabObjective&quot;, &quot;--- The path we're picking: --- (score: &quot; + highestScore + &quot;)&quot;);
          chatCountryNames(&quot;calculateLandgrabObjective&quot;, pickedPath);

          // now we've picked the best path,
          // so we'll package it into an objective HashMap;
          // if there was no path with a score greater than 0 (or no path at all)
          // then we'll just return null;
          if (pickedPath.size() &gt; 0) { // if we picked a path
              // set type
              objective.put(&quot;type&quot;,&quot;landgrab&quot;);

              // set plan
              int[] route = convertListToIntArray(pickedPath); // convert the path we picked into an int array
              ArrayList&lt;int[]&gt; plan = new ArrayList&lt;int[]&gt;();
              plan.add(route); // package the path into an array list
              objective.put(&quot;plan&quot;,plan); // add to objective

              // set cost
              objective.put(&quot;cost&quot;, pickedPathCost);

              // set score
              objective.put(&quot;score&quot;, highestScore);

              // set summary string (this is just useful info for debugging)
              String summary = &quot;landgrab  - score: &quot;;
              String scoreStr = &quot;&quot; + highestScore;
              summary += scoreStr.length() &gt;= 6 ? scoreStr.substring(0, 6) : scoreStr;
              summary += &quot; - &quot; + getCountryName(route[0]) + &quot;...&quot; + getCountryName(route[route.length - 1]) + &quot;, &quot;;
              summary += &quot;cost: &quot; + pickedPathCost;
              objective.put(&quot;summary&quot;, summary);

              return objective;
          } else {
              return null;
          }
      }

      // findTakeoverObjectives() creates an &quot;objective&quot; hashmap for each continent on the board
      // and packages all the objectives in an array list, which it returns to the placeArmies() function
      // which will use the information to decide which ones to take over each turn, if any
      //
      // each takeover objective corresponds to a continent. it packages all the countries in that continent,
      // plus possibly a few external countries (in order to consolidate the borders it needs to defend so there will be fewer of them)
      // into an integer array of country codes called an &quot;area&quot;, and stores that array as a value.
      // it also stores an estimate of the cost of taking over that area,
      // along with the continent bonus and the number of borders.
      //
      // this information should be enough for placeArmies() to prioritize takeover objectives
      // each turn based on the number of armies available and balanced against other types of objectives (such as knockout objectives)
      protected ArrayList&lt;HashMap&gt; findTakeoverObjectives() {
          ArrayList&lt;HashMap&gt; objectiveList = new ArrayList&lt;HashMap&gt;();

          // loop through all the areas to create an &quot;objective&quot; hashmap for each one and add it to objectiveList
          for (int[] area : smartAreas) {

              // create takeover objective of this area
              HashMap&lt;String, Object&gt; objective = calculateTakeoverObjective(area);

              // FORCE THE BOT TO ALWAYS CHOOSE TO TAKEOVER A PARTICULAR CONTINENT FOR TESTING PURPOSES
  /*            int[] continents = (int[]) objective.get(&quot;continentIDs&quot;);
              for (int continent : continents) {
                  String name = board.getContinentName(continent);
                  if (name.equals(&quot;Eastern Africa&quot;)) {
                      objective.put(&quot;score&quot;, Float.MAX_VALUE);
                      board.sendChat(&quot;SETTING SCORE FOR &quot; + name + &quot; TO MAX FLOAT VALUE&quot;);
                  }
              }
  */

              // add objective to objectiveList arraylist
              objectiveList.add(objective);
          }

          return objectiveList;
      }

      protected HashMap&lt;String, Object&gt; calculateTakeoverObjective(int[] area) {
          HashMap&lt;String, Object&gt; objective = new HashMap&lt;String, Object&gt;(); // the Objective hashmap for this continent

          // set objective type
          objective.put(&quot;type&quot;, &quot;takeover&quot;);

          // set continent code
          int[] continents = getAreaContinentIDs(area);
          objective.put(&quot;continentIDs&quot;, continents);

          String[] names = getContinentNames(continents);
          testChat(&quot;calculateTakeoverObjective&quot;, &quot;\n--------------\n&quot; + Arrays.toString(names) + &quot;:&quot;);
          testChat(&quot;calculateTakeoverObjective&quot;, &quot;Area: &quot; + Arrays.toString(area));

          // set area
          objective.put(&quot;area&quot;, area);

          // set continent bonus
          int bonus = getAreaBonuses(area);
          objective.put(&quot;bonus&quot;, bonus);

          // find and set number of borders
          int numBorders = 0;
          for (int country : area) {
              if (isAreaBorder(country, area)) {
                  numBorders += 1;
              }
          }
          objective.put(&quot;numBorders&quot;, numBorders);

          // find and set cost
          //
          // this is an estimate of how many armies we'll need to take over the area,
          // including erecting border garrisons on all the borders.
          // since it's expensive to find the actual attack paths, we're not doing that here.
          // instead, we're simply treating all the enemy countries in the area (plus a path to the area if needed)
          // as one big glob, and estimating the cost as if the glob were a single long path.
          // when it comes time for the bot to actually place armies to take over the area,
          // it will have calculated the attack paths it needs to do so, and figured out exactly how many armies
          // it needs to succesfully prosecute those paths. that number will be more precise than this estimate,
          // but this should be close.
          int cost;
          int[] foreignCountries = getForeignCountriesInArea(area); // get foreign (owned by anyone other than us) countries in the area
          testChat(&quot;calculateTakeoverObjective&quot;, &quot;Enemy Countries: &quot; + Arrays.toString(foreignCountries));
          int[] entryPath = getCheapestRouteToArea(area, false); // cheapest path to area (in case we don't own any countries); pass 'false' because we don't care about ending up at the weakest border of the area
          testChat(&quot;calculateTakeoverObjective&quot;, &quot;Entry Path: &quot; + Arrays.toString(entryPath));
          ArrayList&lt;Integer&gt; pathAndAreaList = new ArrayList&lt;Integer&gt;(); // new arraylist to hold the path and the countries in the area; we'll have to use an arraylist for the moment because it's easier than figuring out how big it has to be before we populate it
          for (int i=1; i&lt;entryPath.length - 1; i++) { // add entryPath to new arraylist, except the first element (which is a country we own, so doesn't count toward cost) and the last element (which is a country in the area, so it's already in foreignCountries)
              pathAndAreaList.add(entryPath[i]);
          }
          for (int country : foreignCountries) { // add the enemy countries in the area into the new arraylist
              pathAndAreaList.add(country);
          }
          int[] pathAndArea = convertListToIntArray(pathAndAreaList); // convert the arraylist into an array for use in getGlobCost(); pathAndArea now holds all the enemy countries in the area we're taking over, plus any enemy countries we have to take over to get there
          testChat(&quot;calculateTakeoverObjective&quot;, &quot;Path and Area: &quot; + Arrays.toString(pathAndArea));
          cost = getGlobCost(pathAndArea); // estimate the cost of the area and the path together
          testChat(&quot;calculateTakeoverObjective&quot;, &quot;Glob cost: &quot; + cost);
          int totalIdealBorders = 0;
          int totalActualBorders = 0;
          for (int country : area) { // now loop through every country in the area to add border garrisons to the cost
              int idealBorderStrength = calculateIdealBorderStrength(country, area);
              int borderStrength = calculateBorderStrength(country, area, idealBorderStrength, bonus); // what the border garrison should be for this country; if it is not a border, this will be 0
              totalIdealBorders += idealBorderStrength;
              totalActualBorders += borderStrength;
              //borderStrength += (int) Math.round((idealBorderStrength - borderStrength) / 3.0f); // just an idea too make areas with high ideal borders less attractive
              int extantBorderArmies = getProjectedCountryOwner(country) == ID ? getProjectedArmies(country) - 1 : 0; // how many (extra) armies are on this country if we own it; if we don't own it, 0
              cost += Math.max(0,borderStrength - extantBorderArmies); // add the border strength we want to the cost minus any armies we already have on that border (or 0 if there are more than enough armies already there)
          }
          objective.put(&quot;cost&quot;, cost);

          // calculate and set score
          float guardedKeepChance = 1.0f;//(float) Math.pow((float) totalActualBorders / (float) totalIdealBorders, 0.5f);
          float gain = guardedKeepChance * (bonus + (float) area.length / 3.0f) + unguardedKeepChance * (float) Math.max(0,entryPath.length-2) / 3.0f; // &lt;gain&gt; is the expected increase in our income: the area bonus + the number of countries divided by 3 + any countries we'll take over on the way there divided by 3, and then multiplied by &lt;unguardedKeepChance&gt; (a global, arbitrary reduction to account for the probability that we won't keep these countries)
  		    float alliedLoss = findAlliedLoss(pathAndArea); // any income loss we will cause our allies (countries we'll take over / 3 and/or any bonuses we'll knock out)
          float enemyLoss = findEnemyLoss(pathAndArea); // &lt;enemyLoss&gt; is how much we reduce the bonus of any enemies we travel through, weighted by their relative income
          float turns = Math.max(1, (float) cost / ((float) board.getPlayerIncome(ID) + .00001f));
          float score = 10f * ((float) gain + enemyLoss - alliedLoss) / (((float) cost + 0.00001f) * (float) Math.pow(turns, .5)); // the score is our gain + the enemies' loss divided by cost and the square root of the number of turns it will take (to discourage large projects)
          objective.put(&quot;score&quot;, score);

          testChat(&quot;calculateTakeoverObjective&quot;, &quot;NEW enemyLoss: &quot; + enemyLoss);

          // set summary string (this is just useful info for debugging)
          String summary = &quot;takeover  - score: &quot;;
          String scoreStr = &quot;&quot; + score;
          summary += scoreStr.length() &gt;= 6 ? scoreStr.substring(0, 6) : scoreStr;
          summary += &quot; - &quot; + Arrays.toString(getContinentNames(continents)) + &quot;, &quot;;
          summary += &quot;bonus: &quot; + bonus + &quot;, cost: &quot; + cost;
          summary += &quot;, keepChance: &quot; + guardedKeepChance;
          summary += &quot;, eLoss: &quot; + enemyLoss + &quot;, aLoss: &quot; + alliedLoss;
          objective.put(&quot;summary&quot;, summary);

          return objective;
      }

  protected float findEnemyLoss(int[] countryList) {
    float enemyLoss = 0.0f;

    Set&lt;Integer&gt; enemyContinents = new HashSet&lt;Integer&gt;(numConts); // set of continents that are fully owned by an enemy
    for (int country : countryList) { // loop through all the countries in our list
      // add all the income of the owner of each country in the list owned by an enemy (i.e. not an ally and not us)
      // and divide by 3 (because each country is worth a 3rd of an income point)
      // at the end, we will divide the total enemyLoss by the total enemy income to get a weighted sum
      // that favors taking over countries/continents owned by stronger enemies
      if (isEnemy(countries[country].getOwner())) {
        enemyLoss += board.getPlayerIncome(countries[country].getOwner()) / 3.0f; // add the income of the owner of each country / 3
      }
      // if an enemy fully owns the continent this country is in
      // add that continent to a set, which will later be used to
      // calculate the enemy bonus loss if we take over this country
      int continent = countries[country].getContinent();
      if (BoardHelper.anyPlayerOwnsContinent(continent, countries)) { // if any player owns this whole continent
        if (isEnemy(countries[BoardHelper.getCountryInContinent(continent, countries)].getOwner())) // if an enemy owns a country (and therefore all countries) in this continent
          enemyContinents.add(continent); // add to set of enemy continents; a set does not admit duplicate members, so each continent will only occur once
      }
    }
    // &lt;enemyLoss&gt; is the total enemy countries divided by three,
    // plus the sum of the owned continent bonuses.
    for (int enemyContinent : enemyContinents) {
      int owner = countries[BoardHelper.getCountryInContinent(enemyContinent, countries)].getOwner();
      int ownerIncome = board.getPlayerIncome(owner);
      enemyLoss += board.getContinentBonus(enemyContinent) * ownerIncome;
    }

    enemyLoss /= getTotalEnemyIncome() + 0.00001f; // divide enemyLoss by total enemy income to get weighted sum

    return enemyLoss;
  }
  // overloaded version to handle arraylists
  protected float findEnemyLoss(ArrayList&lt;Integer&gt; countryList) {
      return findEnemyLoss(convertListToIntArray(countryList));
  }

  	// for a set of countries we're thinking of taking over
  	// return any losses to our allies that would result
  	// by counting both the allied country loss (allied countries / 3)
  	// and any continent bonuses we'd be taking away from our allies
  	protected float findAlliedLoss(int[] countryList) {
  		int alliedCountries = 0; // number of countries in countryList that is owned by an ally
  		Set&lt;Integer&gt; alliedContinents = new HashSet&lt;Integer&gt;(numConts); // set of continents that are fully owned by an ally
  		for (int country : countryList) { // loop through all the countries in our list
  			// add all the countries in the list owned by an ally
  			// the total number of which will be divided by 3 later
  			if (isAlly(countries[country].getOwner())) {
  				alliedCountries += 1;
  			}
  			// if an ally fully owns the continent this country is in
  			// add that continent to a set, which will later be used to
  			// calculate the allied bonus loss if we take over this country
  			int continent = countries[country].getContinent();
  			if (BoardHelper.anyPlayerOwnsContinent(continent, countries)) {
          if (isAlly(countries[BoardHelper.getCountryInContinent(continent, countries)].getOwner()))
  				    alliedContinents.add(continent);
  			}
  		}
  		// &lt;alliedLoss&gt; is the total allied countries divided by three,
  		// plus the sum of the owned continent bonuses.
  		float alliedLoss = 0.0f;
  		alliedLoss = alliedCountries/3.0f;
  		for (int alliedContinent : alliedContinents) {
  			alliedLoss += board.getContinentBonus(alliedContinent);
  		}

  		return alliedLoss;
  	}
    // overloaded version to handle arraylists
    protected float findAlliedLoss(ArrayList&lt;Integer&gt; countryList) {
        return findAlliedLoss(convertListToIntArray(countryList));
    }

      // sort in place an arraylist of objectives
      // by the value of sortKey (only if that value is an integer)
      protected void sortObjectives(ArrayList&lt;HashMap&gt; list, String sortKey) {
          // if there's nothing in the list
          // simply return the original list
          if (list.size() == 0) {
              return;
          }

          // if the values at sortKey are integers
          HashMap&lt;String,Object&gt; someElement = list.get(0); // we'll check the first element to find out what type sortKey is
          if (someElement != null &amp;&amp; someElement.get(sortKey) instanceof Integer) {
              // bubble-sort the arraylist by the value of sortKey
              boolean flag = true;
              HashMap temp = new HashMap();
              int v1, v2;
              HashMap&lt;String, Object&gt; thisObj = new HashMap&lt;String, Object&gt;();
              HashMap&lt;String, Object&gt; nextObj = new HashMap&lt;String, Object&gt;();
              int size = list.size();
              while(flag) {
                  flag = false;
                  for (int i=0; i&lt;size-1; i++) {
                      thisObj = list.get(i); // the element we're on
                      nextObj = list.get(i+1); // the next element, to compare it to

                      if (thisObj != null &amp;&amp; thisObj.containsKey(sortKey)) { // if this element has the sortKey
                          v1 = (Integer) thisObj.get(sortKey); // assign the sortKey value to v1
                      } else { // and if it doesn't
                          v1 = Integer.MIN_VALUE; // assign v1 the lowest possible value, so this element will be moved to the end
                      }
                      if (nextObj != null &amp;&amp; nextObj.containsKey(sortKey)) { // if the next element has the sortKey
                          v2 = (Integer) nextObj.get(sortKey); // assign the sortKey value to v2
                      } else { // and if it doesn't
                          v2 = Integer.MIN_VALUE; // assign v2 the lowest possible value
                      }

                      if (v1 &lt; v2) {
                          temp = list.get(i); // store the value at i
                          list.remove(i); // remove the ith element, and everything after it shifts to the left
                          list.add(i+1,temp); // insert the original ith element at i+1, and everything after it shifts to the right
                          flag = true;
                      }
                  }
              }
          }
          // if the values at sortKey are floats
          else if (someElement != null &amp;&amp; someElement.get(sortKey) instanceof Float) {
              // bubble-sort the arraylist by the value of sortKey
              boolean flag = true;
              HashMap temp = new HashMap();
              float v1, v2;
              HashMap&lt;String, Object&gt; thisObj = new HashMap&lt;String, Object&gt;();
              HashMap&lt;String, Object&gt; nextObj = new HashMap&lt;String, Object&gt;();
              int size = list.size();
              while(flag) {
                  flag = false;
                  for (int i=0; i&lt;size-1; i++) {
                      thisObj = list.get(i); // the element we're on
                      nextObj = list.get(i+1); // the next element, to compare it to

                      if (thisObj != null &amp;&amp; thisObj.containsKey(sortKey)) { // if this element has the sortKey
                          v1 = (Float) thisObj.get(sortKey); // assign the sortKey value to v1
                      } else { // and if it doesn't
                          v1 = -Float.MAX_VALUE; // assign v1 the lowest possible value, so this element will be moved to the end
                      }
                      if (nextObj != null &amp;&amp; nextObj.containsKey(sortKey)) { // if the next element has the sortKey
                          v2 = (Float) nextObj.get(sortKey); // assign the sortKey value to v2
                      } else { // and if it doesn't
                          v2 = -Float.MAX_VALUE; // assign v2 the lowest possible value
                      }

                      if (v1 &lt; v2) {
                          temp = list.get(i); // store the value at i
                          list.remove(i); // remove the ith element, and everything after it shifts to the left
                          list.add(i+1,temp); // insert the original ith element at i+1, and everything after it shifts to the right
                          flag = true;
                      }
                  }
              }
          }

          return;
      }

      // finds all continents that are completely owned and returns an arraylist containing an Objective (hashmap) for each of them
      // Objective hashmaps for knocking out bonuses contain the cost to knock out the continent bonus, the continent bonus, the enemy's current income, an attack path to get to the continent, and where to place armies to execute the attack path
      protected ArrayList&lt;HashMap&gt; findKnockoutObjectives() {
          ArrayList&lt;HashMap&gt; objectiveList = new ArrayList&lt;HashMap&gt;();

          // loop through all the continents on the board
          // if the continent is fully owned, find all the values we want and put them in a hashmap
          // add the hashmap to objectiveList
          for(int continent=0; continent&lt;numConts; continent++) { // loop through all the continents
              HashMap&lt;String, Object&gt; objective = new HashMap&lt;String, Object&gt;(); // the Objective hashmap for this continent
              objective = calculateKnockoutObjective(continent);
              if (objective != null) {
                  objectiveList.add(objective);
              }

          }
          return objectiveList;
      }

      // creates/calculates knockout objective for the given continent
      // if the continent is not fully owned by an enemy, returns null
      protected HashMap&lt;String, Object&gt; calculateKnockoutObjective(int continent) {
          int[] area = getCountriesInContinent(continent);
          int owner = countries[BoardHelper.getCountryInContinent(continent, countries)].getOwner(); // the owner of some country in this continent
          if (BoardHelper.anyPlayerOwnsContinent(continent, countries) &amp;&amp; isEnemy(owner) &amp;&amp; !battlePlanHasCountryIn(area)) { // if an enemy fully owns this continent
              HashMap&lt;String, Object&gt; objective = new HashMap&lt;String, Object&gt;(); // the Objective hashmap for this continent

              // set objective type
              objective.put(&quot;type&quot;, &quot;knockout&quot;);

              // set continent code
              objective.put(&quot;continentID&quot;, continent);

              // set continent bonus
              int bonus = board.getContinentBonus(continent);
              objective.put(&quot;bonus&quot;, bonus);

              // set enemy income
              int enemyIncome = board.getPlayerIncome(owner);
              objective.put(&quot;enemyIncome&quot;, enemyIncome);

              // find and set route
              //
              // first, actually find the cheapest route to the continent
              // we pass 'true' to the function to tell it to account for the number of armies
              // on the border country we end up at, because we want to find the weakest way into the continent
              int[] route = getCheapestRouteToCont(continent, true);
              ArrayList&lt;int[]&gt; plan = new ArrayList&lt;int[]&gt;();
              plan.add(route); // package the path into an array list
              objective.put(&quot;plan&quot;,plan);

              // find and set cost
              int cost = getPathCost(route);
              objective.put(&quot;cost&quot;, cost);

              // calculate and set score
              int totalEnemyIncome = getTotalEnemyIncome();
              int income = board.getPlayerIncome(ID); // our income
              float score = 10f * ((float) bonus * enemyIncome) / ( (cost + 0.00001f) * (totalEnemyIncome + 0.00001f));
              objective.put(&quot;oldScore&quot;, score);

              // calculate and set score
              float countriesGain = 0.0f; // countriesGain is how much we reduce the bonus of any enemies we travel through, weighted by their relative income
              for (int i=1; i&lt;route.length; i++) { // loop through each country in the route, except for the first one, which we own
                  countriesGain += board.getPlayerIncome(countries[route[i]].getOwner()); // add the income of the owner of each country
              }
              countriesGain /= 3 * totalEnemyIncome + 0.00001f; // divide the total by 3, because every 3 countries is worth 1 income point, and divide by total enemy income
              float continentGain = ((float) bonus * enemyIncome) / (totalEnemyIncome + 0.00001f); // continentGain is how much we reduce the bonus of the enemy that owns the continent by taking away the continent, weighted by its relative income
              score = 10f * (countriesGain + continentGain) / (cost + 0.00001f); // score is the total gain divided by the cost
              objective.put(&quot;score&quot;, score);

              // set summary string (just some useful info for debugging)
              String summary = &quot;knockout - score: &quot;;
              String scoreStr = &quot;&quot; + score;
              summary += scoreStr.length() &gt;= 6 ? scoreStr.substring(0, 6) : scoreStr;
              summary += &quot; - &quot; + board.getContinentName(continent);
              summary += &quot;, bonus: &quot; + bonus + &quot;, cost: &quot; + cost;
              objective.put(&quot;summary&quot;, summary);

              return objective;
          } else {
              return null;
          }
      }

      // operates on the global HashMap &lt;borderArmies&gt;, which contains the border garrison strength calculated
      // for all the border countries of all the areas we've decided to take over;
      // this function resets those values to equal the number of armies actually on each country in the hashmap
      // (or removes the country from the hashmap if we no longer own it);
      // we do this at the beginning of each turn; see placeArmies() where the function is called for why;
      // also removes any countries from &lt;idealBorderArmies&gt; that we no longer own, but does not adjust the values
      // of the ones we still do own
      protected void resetBorderArmies() {
          Iterator iter = borderArmies.keySet().iterator();
          while (iter.hasNext()) { // iterate through the hashmap
              int key = (Integer) iter.next();
              Country country = countries[key];
              if (country.getOwner() == ID) { // if we own this country
                  borderArmies.put(key, country.getArmies() - 1); // set the value to the number of armies on that country (minus 1)
              } else { // otherwise we don't own this country
                  iter.remove(); // so remove this entry from the hashmap altogether
              }
          }
          Iterator iter1 = idealBorderArmies.keySet().iterator();
          while (iter1.hasNext()) { // iterate through the hashmap
              int key = (Integer) iter1.next();
              Country country = countries[key];
              if (country.getOwner() != ID) { // if we don't own this country
                  iter1.remove(); // remove this entry from the hashmap altogether
              }
          }
      }

      // checks if country is in borderArmies hashmap, and if it is, returns the value, if not, returns 0
      // i.e. if the country is a border, this function will return the number of armies we intend to put/leave on it as a garrison
      protected int checkBorderStrength(int country) {
          if (borderArmies.get(country) != null) {
              return borderArmies.get(country);
          }
          return 0;
      }

      // checks if country is in idealBorderArmies hashmap, and if it is, returns the value, if not, returns 0
      // i.e. if the country is a border, this function will return the number of armies that would make up a garrison of ideal strength
      protected int checkIdealBorderStrength(int country) {
          if (idealBorderArmies.get(country) != null) {
              return idealBorderArmies.get(country);
          }
          return 0;
      }

      // figures out how many armies to put on each border country of the given area
      // stores the number of armies it calculates for each country in the global hashmap borderArmies
      // does NOT actually place those armies on the countries
      protected void setBorderStrength(int[] area) {
          int[] borders = getAreaBorders(area);
          int numBorders = borders.length; // the number of borders &lt;area&gt; has
          int areaBonus = getAreaBonuses(area); // any continent bonuses contained within &lt;area&gt;
          for (int country : borders) {
              int idealStrength = calculateIdealBorderStrength(country, area);
              int strength = calculateBorderStrength(country, area, idealStrength, areaBonus);
              borderArmies.put(country, strength); // borderArmies is a global hashmap
              idealBorderArmies.put(country, idealStrength); // idealBorderArmies is a global hashmap
          }
      }

      // calculate how many armies to leave on the given country as a border garrison
      // if the country is not a border, will return 0;
      protected int calculateBorderStrength(int country, int[] area, int idealStrength, int areaBonus) {
          int strength = 0;
          if (isAreaBorder(country, area)) { // if &lt;country&gt; is a border of &lt;area&gt;

              // find the relative value of this area compared to the highest continent bonus on this map
              // which we'll use to tailor the garrison strength for this country to the area's &quot;importance&quot; as it were
              int biggestBonus = getBiggestContinentBonus();
              double areaValue = Math.pow(areaBonus, 0.5)/Math.pow(biggestBonus, 0.5); // we soften the ratio a bit by using square roots

              // find any armies we may already have on this country
              // and decide the maximum number of armies we want to add to that each turn (as a portion of our income)
              // (up to the ideal value, which we'll calculate later)
              double income = (double) board.getPlayerIncome(ID);
              double incomePortion = income / 4.0d; // our income divided by 4
              int extantArmies = 0; // the number of (our) armies on this country, if any
              if (countries[country].getOwner() == ID) { // if we (actually) own the country
                  extantArmies = countries[country].getArmies(); // get the extant armies
              }
              // here we cheat a little, and just make sure that &lt;extantArmies&gt; is never reported as less than &lt;incomePortion&gt; (rounded up);
              // that just gives us a boost when we're first putting garrisons on this country,
              // by allowing us to put double &lt;incomePortion&gt; the first time around
              extantArmies = (int) Math.ceil(Math.max(extantArmies, incomePortion));

              // so now we're ready to calculate the strength;
              // sets &lt;strength&gt; to the ideal strength, scaled down by the relative value of the bonus we're protecting
              // for a small bonus it will have an insufficient border,
              // and the largest bonus on the board will have a bonus equal to &lt;idealStrength&gt;
              // except if &lt;extantArmies&gt; + &lt;incomePortion&gt; is smaller than that number, in which case we limit &lt;strength&gt; to that
              // so we never have to add more than that much of our income at once
              // in order to keep the border garrison requirements from being out of control
              // but the garrison will be allowed to grow each turn until it reaches the ideal value
              strength = (int) Math.ceil(Math.min(idealStrength * areaValue,  (double) income / 2));//extantArmies + incomePortion)); &lt;-- commenting out the incremental limit for now because it doesn't work very well; we'll come back to it

              testChat(&quot;calculateBorderStrength&quot;, &quot;Border strength of &quot; + countries[country].getName() + &quot; is &quot; + strength);
          }

          return strength;
      }
      // overloaded version without the &lt;areaBonus&gt; parameter
      protected int calculateBorderStrength(int country, int[] area, int idealStrength) {
          int areaBonus = getAreaBonuses(area); // set this to the bonus of all continents completely contained by &lt;area&gt;
          return calculateBorderStrength(country, area, idealStrength, areaBonus);
      }
      // overloaded version without the &lt;idealStrength&gt; or &lt;areaBonus&gt; parameters
      protected int calculateBorderStrength(int country, int[] area) {
          int idealStrength = calculateIdealBorderStrength(country, area);
          return calculateBorderStrength(country, area, idealStrength);
      }

      // called by calculateBorderStrength()
      // returns the ideal strength for this border, which is
      // the magnitude of the greatest nearby enemy threat to the given border country
      // plus a certain amount of padding
      protected int calculateIdealBorderStrength(int borderCountry, int[] area) {
          int maxDepth = 5; // the depth we want to search out to
          int currentDepth = 0; // begin with a depth of 0
          int armiesThusFar = 0; // the armies on a given path so far
          ArrayList&lt;Integer&gt; blacklist = new ArrayList&lt;Integer&gt;(); // the blacklist keeps track of the players whose countries we've seen so far along a given path
          blacklist.add(ID); // begin by adding ourselves, so we don't ever consider ourselves a threat

          // recursively find the greatest threat from all neighbors of &lt;borderCountry&gt; out to &lt;currentDepth&gt;
          int greatestThreat = findNeighborsThreat(borderCountry, area, currentDepth, maxDepth, armiesThusFar, blacklist);

          // multiply the greatest threat by 1.2, because this should give us decent odds of repelling an attack
          int idealStrength = (int) Math.round(greatestThreat * 1.2d);

          return idealStrength;
      }

      // called by calculateIdealBorderStrength()
      // recursively finds neighbors of given country, and finds the threat level of those neighbors,
      // then compares all the threats it finds to each other and returns the highest one
      protected int findNeighborsThreat(int country, int[] area, int currentDepth, int maxDepth, int armiesThusFar, ArrayList&lt;Integer&gt; oldBlacklist) {
          // make deep copy of oldBlacklist, so we don't mess with other branches
          ArrayList&lt;Integer&gt; blacklist = new ArrayList&lt;Integer&gt;();
          blacklist.addAll(oldBlacklist);

          int threat = 0; // the threat from this country
          int owner = getProjectedCountryOwner(country); // the owner of &lt;country&gt;
          int armies = getProjectedArmies(country); // the armies on &lt;country&gt;

          // if we're not on the first country (the actual border country)
          // calculate the threat
          if (currentDepth &gt; 0) {
              // if &lt;owner&gt; is not in blacklist, then we haven't run across a country owned by this player before
              // so we assess the threat of this country
              // (if we HAVE seen this owner before, we don't assess the threat, because the player won't
              // be able to get to the area along this path, because it will run into itself, in which case
              // we will leave threat at 0, as it was initially assigned)
              if (!isInArray(owner, blacklist)) {
                  threat = Math.max(0,armies + getPlayerIncomeAndCards(owner) - armiesThusFar - currentDepth);
                  blacklist.add(owner); // now we've seen this owner on this path, so add it to blacklist
              }

              // add the armies on this country to the total armies we've seen so far along this path
              // to pass to the new neighbors
              armiesThusFar += armies;
          }

          // iterate &lt;currentDepth&gt; to pass to the new neighbors
          currentDepth++;

          // if we haven't exceeded &lt;maxDepth&gt; yet, go on to check neighbors
          if (currentDepth &lt;= maxDepth) {
              // find neighbors of &lt;country&gt;
              int[] neighbors = BoardHelper.getAttackList(countries[country], countries);

              // loop over the neighbors of &lt;country&gt; and recurse on them
              for(int neighbor : neighbors) {
                  // only recurse on neighbors that aren't in the area
                  if (!isInArray(neighbor, area)) {
                      int neighborThreat = findNeighborsThreat(neighbor, area, currentDepth, maxDepth, armiesThusFar, blacklist);
                      if (neighborThreat &gt; threat) {
                          threat = neighborThreat;
                      }
                  }
              }
          }

          return threat;
      }

      // called by placeArmies()
      // given a number of armies and a set of paths to take over, this function calculates the number of armies required to do so
      // and places them appropriately at the starting country of each path
      // it then returns the number of armies leftover
      protected int placeArmiesOnRoutes(ArrayList&lt;int[]&gt; plan, int numberOfArmies) {
          testChat(&quot;placeArmiesOnRoutes&quot;, &quot;----- Place Armies On Routes -----&quot;);

          // we need an associative array to remember the costs we calculate for each path
          // so that in case any paths share a starting country, we don't double count what we've already put there
          Map&lt;Integer, Integer&gt; previousCosts = new HashMap&lt;Integer, Integer&gt;();

          for (int i=0; i&lt;plan.size(); i++) { // loop through the entire plan
              int startCountry = plan.get(i)[0]; // the first country on the path we're on
              if (countries[startCountry].getOwner() == ID) { // if we own the starting country, it is an original path, so test it; otherwise, it is a fork-branch, so ignore it at this stage
                  // calculateCladeCost() returns the number of armies it will take to conquer this path and all of its forks
                  // not accounting for how many armies we have on the starting country
                  int cost = calculateCladeCost(plan, i);

                  testChat(&quot;placeArmiesOnRoutes&quot;,&quot;--- total cost of above clade: &quot; + cost);

                  // find out if startCountry is a border country, and if so, find out how much we want to place there as we pass
                  // we will place this number on the country but will NOT add it to costs, so that it will not be added to reservedArmies
                  // on future iterations of the loop, essentially ensuring that it will only be added to startCountry once
                  // even if there are multiple paths starting from the same country
                  // (findBorderStrength() is also run on every other country in the path and its forks when we calculate the cost for it)
                  int borderGarrison = checkBorderStrength(startCountry);

                  // subtract the number of armies already on the starting country (minus 1) from cost
                  // not including any armies we may have placed or reserved there on previous iterations of the loop
                  // unless that number would be &lt; 0, in which case, make it 0, because we don't want to try to place negative armies
                  int extantArmies = countries[startCountry].getArmies() - 1; // armies actually on the country - 1
                  int reservedArmies = 0;
                  if (previousCosts.get(startCountry) != null) {
                      reservedArmies = previousCosts.get(startCountry); // total costs we calculated we needed for that country on previous iterations (including any armies that were already there at the beginning)
                  }
                  int discountArmies = extantArmies - reservedArmies; // armies to discount are the armies on the country minus any armies we've already reserved there
                  int armiesToPlace = Math.max(0,cost + borderGarrison - discountArmies); // subtract discountArmies from cost, but if that's negative, make it 0

                  // armiesToPlace should not be greater than numberOfArmies
                  armiesToPlace = Math.min(numberOfArmies, armiesToPlace);

                  testChat(&quot;placeArmiesOnRoutes&quot;,&quot;extantArmies: &quot; + extantArmies + &quot;\n                  reservedArmies: &quot; + reservedArmies + &quot;\n                  discountArmies: &quot; + discountArmies + &quot;\n                  Border garrison: &quot; + borderGarrison);
                  testChat(&quot;placeArmiesOnRoutes&quot;,&quot;--- amount we're actually putting on it: &quot; + armiesToPlace);

                  // place armiesToPlace on the starting country of the path
                  // and subtract armiesToPlace from numberOfArmies
                  // if it is &lt;= 0, we already have enough armies there, so we don't need to place any
                  board.placeArmies(armiesToPlace, startCountry);
                  numberOfArmies -= armiesToPlace;

                  // if numberOfArmies is &lt;= 0, we've used up all the armies, so break the loop, we're done
                  if (numberOfArmies &lt;= 0) {
                      break;
                  }

                  // add the cost we calculated (NOT the adjusted figure, armiesToPlace) to the previousCosts hashmap entry for startCountry
                  // so that future iterations of the loop can check it
                  // this acts as a sort of &quot;reservation&quot;, so that when future iterations of the loop
                  // (in the case of forks that leave from the same starting country) adjust their costs to the extant armies
                  // they don't count the ones we just placed there
                  if (previousCosts.get(startCountry) == null) {
                      previousCosts.put(startCountry, cost);
                  } else {
                      previousCosts.put(startCountry, previousCosts.get(startCountry) + cost);
                  }

              }
          }

          testChat(&quot;placeArmiesOnRoutes&quot;, &quot;number of armies left: &quot; + numberOfArmies);

          // return the number of armies we have left
          return numberOfArmies;
      }

      // calculates the cost of taking over a clade
      // a clade is a monophyletic tree of paths, i.e. a path and all of its forks (and all of their forks, etc.)
      // clades are not represented in our code as single objects, so this function must find the forks of the initial path itself;
      // the function is passed the entire battle plan (&quot;plan&quot;), which may contain multiple clades, and an index, which tells it which original path in the plan to work on;
      // it follows that original path only, and finds all of its forks, and calls itself recursively to find all of its forks' forks, etc.
      // and adds up all of their costs together and returns that number
      protected int calculateCladeCost(ArrayList&lt;int[]&gt; plan, int index) {
          int cost = 0;
          int[] path = plan.get(index);
          cost += getPathCostWithBorders(path); // calculate the cost of the main path

          chatCountryNames(&quot;calculateCladeCost&quot;, path);
          testChat(&quot;calculateCladeCost&quot;,&quot;Cost to take over the above path: &quot; + cost);

          for (int i=1; i&lt;path.length; i++) { // loop through the main path to check to see if each country is a branch point for a fork
              for (int j=0; j&lt;plan.size(); j++) { // loop through the rest of the paths in the plan to find any that begin at this country
                  if (path[i] == plan.get(j)[0]) { // if one does, it is a fork
                      cost += calculateCladeCost(plan, j); // so recurse, and add that result to the cost
                  }
              }
          }

          return cost;
      }

      // calculate the number of armies it will require to take over a whole path (not including the starting country, which we assume we own)
      // does not subtract the number of armies we already have on the first country in the path
      // does not account for any forks, only calculates over a single path
      // note that &quot;cost&quot; in this function is not simply the number of enemy armies in the way
      // rather, it is an estimate of how many armies it will actually take to conquer the given path
      // *** including the cost of any border garrisons we will want to leave along the way ***
      // calls getPathCost()
      protected int getPathCostWithBorders(int[] path) {
          // get the cost of actually taking over the path
          int cost = getPathCost(path);

          // add the cost of any border garrisons we want to leave along the way
          for (int i=1; i&lt;path.length; i++) { // loop through the path, beginning on the SECOND country
              cost += checkBorderStrength(path[i]); // check if we want to leave any armies on this country as a border garrison, add that value to cost
          }

          return cost;
      }

      // calculate the number of armies it will require to take over a whole path (not including the starting country, which we assume we own)
      // does not subtract the number of armies we already have on the first country in the path
      // does not account for any forks, only calculates over a single path
      // note that &quot;cost&quot; in this function is not simply the number of enemy armies in the way
      // rather, it is an estimate of how many armies it will actually take to conquer the given path
      protected int getPathCost(int[] path) {
          double cost = 0;
          for (int i=1; i&lt;path.length-1; i++) { // loop through the path, beginning on the SECOND country and ending on the SECOND TO LAST country (we'll do the last country separately after the loop)
              // this is the (approximated) formula to calculate the number of armies needed to win an intermediate battle (one not at the end of a path, so the attacker always gets to roll 3 dice) with 78% certainty (the choice to use 78% was just a judgment call)
              int defenders = countries[path[i]].getArmies(); // enemy armies on this country
              cost += (7161d / 8391d) * (double) defenders + (1.3316d * Math.pow((double) defenders,.4665d));
          }
          // now get the cost for the last battle in the path at 78% certainty (the formula is different because this is a terminal battle (at the end of a path) so the attacker may have to roll 2 dice or 1 die near the end of the battle)
          if (path.length &gt; 1) {
              int defenders = countries[path[path.length-1]].getArmies(); // the enemy armies on the last country
              cost += (7161d / 8391d) * (double) defenders + (1.7273d * Math.pow((double) defenders,.4301d));
          }

          return (int) Math.round(cost); // round to the nearest integer and return
      }

      // when first estimating the cost of taking over an area without calculating all the actual attack paths,
      // we will package all the unowned countries into an int[] and call this function
      // it adds a dummy element to the beginning of the array and calls getPathCost() to get an estimate of the
      // cost of taking over the area. The dummy element is required, because getPathCost() assumes the first
      // country in the array is one we own, which it usually is, but in this case is not
      // this may seem kludgy, but the alternatives are all worse
      protected int getGlobCost(int[] glob) {
          int[] dummyGlob = new int[glob.length + 1];
          dummyGlob[0] = -1;
          System.arraycopy(glob, 0, dummyGlob, 1, glob.length);

          return getPathCost(dummyGlob);
      }

      // note: I wrote the following ugly crap intending to make use of it in the placeArmiesOnRoutes() function
      //       but decided to go another way. I'll leave it here in case it's needed later (god, I hope not)
      //
      // given an entire takeover plan (plan) and the index of a single path within it,
      // returns true if the starting country of that path is not found in any other path,
      // OR if it is the first of multiple original paths that share the same starting country
      // in other words, it should return true for every path that is not a fork-branch of another path
      // but since some paths fork from their first element, in which case there would be multiple paths starting from the same country (which we should already own),
      // we call the first one of those we come across an original path (true), and the following ones we call forks (false)
      protected boolean isOriginalPath(ArrayList&lt;int[]&gt; plan, int index) {
          int startCountry = plan.get(index)[0]; // the starting country of the path we're testing

          for (int i=0; i&lt;plan.size(); i++) { // loop through the entire plan
              if (i != index) { // don't check against the path we're testing
                  int[] checkPath = plan.get(i);
                  for (int j=0; j&lt;checkPath.length; j++) { // loop through the path
                      if (checkPath[j] == startCountry) { // if we found startCountry in this path
                          // if the match occurs at the beginning of a path that appears after the path we're testing
                          // then that match doesn't count. the reason for this is that in the case of forks that happen
                          // at the beginning of a pair (or more) of paths, we need to treat one of them as the original,
                          // and the rest as forks; we've chosen to treat the first one as the original in that case.
                          // so the following if-statement rules out the first one by only returning false if the match we found
                          // occurs either in the middle of a path or at the beginning of a PRIOR path only, and NOT at the beginning of a subsequent path
                          if (j!=0 || i &lt; index) {
                              return false;
                          }
                      }
                  }
              }
          }

          // if we're here, we didn't find anything, so it's an original path; return true
          return true;
      }

      // will return a set of all possible terminal attack paths from a country (optionally supplied by passing startCountry)
      // if startCountry is not provided, will find paths from all the starting countries we own in the countryList
      // if we don't own any countries in the countryList, we'll find one nearby to start on
      protected ArrayList getAreaTakeoverPaths(int[] countryList) {
          testChat(&quot;getAreaTakeoverPaths&quot;, &quot;-- GET AREA TAKEOVER PATHS --&quot;);
          testChat(&quot;getAreaTakeoverPaths&quot;, &quot;startCountry not given&quot;);

          // we'll store all candidate paths here (individual paths are integer arrays)
          ArrayList&lt;int[]&gt; paths = new ArrayList&lt;int[]&gt;();

          // a global variable we need in order to keep track of how many paths
          // have been found so far
          pathCount = 0;

          // we'll test every path from every country we own in the countryList
          // if we don't own any countries in countryList, we'll find a country close-by to start from

          int[] candidates = getPlayerCountriesInArea(countryList); // get countries in countryList that we own

          if (candidates.length &gt; 0) { // if we own any countries in countryList

              // just testing to see if we found the countries we own
              String[] countryNames = getCountryNames(candidates);
              testChat(&quot;getAreaTakeoverPaths&quot;, &quot;countries we own in area: &quot; + Arrays.toString(countryNames));

              // loop through candidates array, finding paths for each of them
              int[] initialPath = new int[1];
              for (int i=0; i&lt;candidates.length; i++) {
                  initialPath[0] = candidates[i];
                  paths.addAll(findAreaPaths(initialPath, countryList)); // concatenate results from all of them together in the paths ArrayList
              }
          }
          else { // we don't own any countries in countryList
              testChat(&quot;getAreaTakeoverPaths&quot;, &quot;we don't own any countries in area&quot;);

              // find the cheapest path to it from some country we own
              // we pass 'false' as the second parameter to tell the function that we don't care
              // how many armies are on the border of the area that we end up at; we only care about
              // the cost of the path up until that point, since we're planning on taking over the whole area anyway
              int[] initialPath = getCheapestRouteToArea(countryList, false);

              if (initialPath != null) {
                  String[] countryNames = getCountryNames(initialPath);
                  testChat(&quot;getAreaTakeoverPaths&quot;, &quot;Path to continent: &quot; + Arrays.toString(countryNames));

                  // use that as starting country
                  paths = findAreaPaths(initialPath, countryList);
              } else {
                  // if we're here, we couldn't find a country we own that can reach countryList for some reason
                  // so all we can do is return empty-handed
                  System.out.println(&quot;ERROR in getAreaTakeoverPaths() - could not get initial path to area&quot;);
                  return paths;
              }
          }

          testChat(&quot;getAreaTakeoverPaths&quot;, &quot;pathCount: &quot; + pathCount);

          // now we have a complete list of terminal paths from every country we own in the area (countryList)
          // (or from a nearby country in the case that we don't own any in the area itself)
          // but we still need to go over all of the countries we have paths to, and see if any are left out.
          // this will happen in the case of non-contigious areas, i.e. &quot;you can't get there from here&quot;
          // or it may also happen if we hit the &lt;pathCount&gt; limit in findAreaPaths() before we got to everything;
          // so we'll check if any of the countries in countryList are not in any of the paths we found
          // and repackage just them as a new area, call getAreaTakeoverPaths() recursively on that area,
          // and add the results to the paths ArrayList
          ArrayList&lt;Integer&gt; countriesLeft = new ArrayList&lt;Integer&gt;(); // (note that countriesLeft is an ArrayList, which is atypical (usually integer arrays are used))
          for (int i=0; i&lt;countryList.length; i++) { // create ArrayList of whole area
              countriesLeft.add(countryList[i]);
          }
          int pathsSize = paths.size();
          iLoop: for (int i=0; i&lt;pathsSize; i++) { // loop through all paths
              int[] path = paths.get(i);
              for (int j=0; j&lt;path.length; j++) { // loop through all countries in path
                  for (int k=0; k&lt;countriesLeft.size(); k++) { // loop through all countries in area that we haven't seen yet (that's what countriesLeft represents)
                      if (path[j] == countriesLeft.get(k)) { // if this country is in a path
                          countriesLeft.remove(k); // remove it from countriesLeft
                          break; // and continue checking the rest of them
                      }
                  }
                  if (countriesLeft.size() == 0) { // if this is empty, every country in area is accounted for in paths
                      break iLoop; // so stop looking, we're done
                  }
              }
          }

          // now anything left in countriesLeft was not accounted for in any path we found
          // (which could happen if the original area we searched was not contiguous and we didn't own a country in at least one of the discrete parts,
          // or if we had to stop when we hit the &lt;pathCount&gt; limit before we got to all the countries)
          // so convert it into an integer array and pass it into getAreaTakeoverPaths() recursively as a new area to search
          // then we'll add the results of that function call to the paths we already found
          if (countriesLeft.size() &gt; 0) {
              int[] countriesLeftArray = new int[countriesLeft.size()];
              for (int i=0; i&lt;countriesLeftArray.length; i++) {
                  countriesLeftArray[i] = countriesLeft.get(i).intValue();
              }
              String[] countryNames = getCountryNames(countriesLeftArray);

              testChat(&quot;getAreaTakeoverPaths&quot;, &quot;There are &quot; + countriesLeftArray.length + &quot; countries left&quot;);
              //testChat(&quot;getAreaTakeoverPaths&quot;, &quot;countriesLeft: &quot; + Arrays.toString(countryNames));

              testChat(&quot;getAreaTakeoverPaths&quot;, &quot;===========&gt;&gt; RECURSE on countriesLeft&quot;);
              paths.addAll(getAreaTakeoverPaths(countriesLeftArray));
              testChat(&quot;getAreaTakeoverPaths&quot;, &quot;&lt;&lt;=========== END RECURSE&quot;);

          } else {
              testChat(&quot;getAreaTakeoverPaths&quot;, &quot;all countries were accounted for in the list of paths we found&quot;);
          }

          // now we will add single-country paths for each country we own
          // these aren't terminal paths, of course; they're kind of dummy paths
          // they will be added to the battlePlan, from which the border countries among them will be armed;
          // by treating the border countries as paths, we harness a lot of existing logic for placing armies
          for (int country : countryList) {
              if (getProjectedCountryOwner(country) == ID) {
                  paths.add(new int[]{country});
              }
          }

          testChat(&quot;getAreaTakeoverPaths&quot;, &quot;There are &quot; + paths.size() + &quot; terminal paths&quot;);
          //chatCountryNames(&quot;getAreaTakeoverPaths&quot;, paths);

          // return the paths
          return paths;
      }
      // overload getAreaTakeoverPaths to allow a double parameter version
      // in this version, a starting country is supplied, and we'll only search for paths starting from that country
      protected ArrayList getAreaTakeoverPaths(int[] countryList, int startCountry) {
          testChat(&quot;getAreaTakeoverPaths&quot;, &quot;-- GET AREA TAKEOVER PATHS --&quot;);
          testChat(&quot;getAreaTakeoverPaths&quot;, &quot;startCountry is &quot; + startCountry);

          // we'll store all candidate paths here (individual paths are integer arrays)
          ArrayList&lt;int[]&gt; paths = new ArrayList&lt;int[]&gt;();

          // create an new history (integer array) containing only the starting country
          int[] initialPath = new int[1];
          initialPath[0] = startCountry;

          // find paths
          paths = findAreaPaths(initialPath, countryList);

          // return the paths
          return paths;
      }

      // find the nearest country owned by owner and return the cheapest path
      // from it to a country in the given continent
      // just packages all the countries in that continent into an area and calls getCheapestRouteToArea
      protected int[] getCheapestRouteToCont(int cont, boolean into, int owner) {
          return getCheapestRouteToArea(getCountriesInContinent(cont), into, owner);
      }
      // overload getCheapestRouteToCont to allow a single parameter version
      // if no ID is provided, assume it should be the owner
      protected int[] getCheapestRouteToCont(int cont, boolean into) {
          return getCheapestRouteToCont(cont, into, ID);
      }

      // find the cheapest path from any country owned by owner
      // to a country in the given area (area could be a continent, for example).
      // the boolean parameter &quot;into&quot; tells the function whether to take into account the
      // number of armies on the area's border country at the end of the path.
      // if &quot;into&quot; is true, we add that country's armies to the cost; if false, we don't
      // so that when we're using this function to knockout an enemy bonus, we find the weakest border (all else being equal)
      // but when we're taking over the whole continent, we simply find the cheapest path to the continent
      // without regard to how many countries are on the border we end up at
      // this is a modified version of the BoardHelper method cheapestRouteFromOwnerToCont()
      protected int[] getCheapestRouteToArea(int[] area, boolean into, int owner) {

          String[] countryNames = getCountryNames(area);
          testChat(&quot;getCheapestRouteToArea&quot;, &quot;getCheapestRouteToArea area: &quot; + Arrays.toString(countryNames));

          if (owner &lt; 0 || area.length == 0) {
              System.out.println(&quot;ERROR in getCheapestRouteToArea() -&gt; bad parameters&quot;);
              return null;
          }

          // first, check to see if we already own a country in the area.
          int[] ownedCountries = getPlayerCountriesInArea(area, owner);
          if (ownedCountries.length &gt; 0) {
              // the player owns a country in the area already. That country itself is the cheapest route
              // so simply return the first one in the list of owned countries
              return new int[] { ownedCountries[0] };
          }

          // We keep track of which countries we have already seen (so we don't
          // consider the same country twice). We do it with a boolean array, with
          // a true/false value for each of the countries:
          boolean[] haveSeenAlready = new boolean[countries.length];
          for (int i = 0; i &lt; countries.length; i++)
          {
              haveSeenAlready[i] = false;
          }

          // Create a Q (with a history) to store the country-codes and their cost
          // so far:
          CountryPathStack Q = new CountryPathStack();

          // We explore from all the borders of &lt;area&gt;
          int testCode, armiesSoFar;
          int[] testCodeHistory;
          int[] borderCodes = getAreaBorders(area);
          for (int i = 0; i &lt; borderCodes.length; i++) {
              testCode = borderCodes[i];
              if (into == true) { // if we care about finding the weakest border
                  armiesSoFar = countries[borderCodes[i]].getArmies(); // add the armies of the starting country to the cost
              } else { // if we don't
                  armiesSoFar = 0; // start with a cost of 0
              }
              testCodeHistory = new int[1];
              testCodeHistory[0] = testCode;
              haveSeenAlready[testCode] = true;

              Q.pushWithValueAndHistory(countries[borderCodes[i]], armiesSoFar, testCodeHistory );
          }

          // So now we have all the area borders in the Q
          // (all with either cost 0, or the cost of the armies on the border country, depending on the value of &quot;into&quot;),
          // expand every possible outward path (in the order of cost).
          // eventually we should find a country owned by &lt;owner&gt;,
          // then we return that path's history
          while ( true ) {
              armiesSoFar = Q.topValue();
              testCodeHistory = Q.topHistory();
              testCode = Q.pop();

              // if we own &lt;testCode&gt; or if we are planning to this turn
              if ( getProjectedCountryOwner(testCode) == owner ) {
                  // we have found the best path. return it
                  return testCodeHistory;
              }

              int[] canAttackInto = BoardHelper.getAttackList(countries[testCode], countries);

              for (int i=0; i&lt;canAttackInto.length; i++) {
                  if (!haveSeenAlready[canAttackInto[i]]) {
                      // Create the new node's history array. (It is just
                      // testCode's history with its CC added at the beginning):
                      int[] newHistory = new int[ testCodeHistory.length + 1 ];
                      newHistory[0] = canAttackInto[i];
                      for (int j = 1; j &lt; newHistory.length; j++) {
                          newHistory[j] = testCodeHistory[j-1];
                      }
                      Q.pushWithValueAndHistory(
                                                countries[canAttackInto[i]],
                                                // If the neighbor is owned by the proper person then subtract
                                                // its armies from the value so it gets pulled off the Q next.
                                                // Without this there is a bug
                                                armiesSoFar + (getProjectedCountryOwner(canAttackInto[i]) == owner ? -getProjectedArmies(canAttackInto[i]) : getProjectedArmies(canAttackInto[i])),
                                                newHistory );
                      haveSeenAlready[ countries[canAttackInto[i]].getCode() ] = true;
                  }
              }

              // as far as we know, this should only happen in maps with one-way connections
              // if the only country owned by owner is trapped behind a one-way connection from the area
              if (Q.isEmpty()) {
                  System.out.println(&quot;ERROR in getCheapestRouteToArea - could not find a country owned by owner&quot;);
                  return null;
              }
          }
      }
      // overload getCheapestRouteToArea to allow a single parameter version
      // if no ID is provided, assume it should be the owner
      protected int[] getCheapestRouteToArea(int[] area, boolean into) {
          return getCheapestRouteToArea(area, into, ID);
      }

      // called in the placeArmies() phase
      // given that the bot has already chosen an area to pursue, this function should find a comprehensive plan
      // to takeover that continent/area in the form of a set of int[] arrays of country codes that form attack paths from countries we own
      // this function calls getAreaTakeoverPaths() to get a list of all possible takeover paths (allPaths) through a given country list (area)
      // then from those finds a comprehensive set of paths that pass through every enemy country in the area, including forks and islands
      // ideally, it will find as few as possible that contain every enemy country in the area (as well as every country we own, even if that means a dummy path of only 1 country)
      // getAreaTakeoverPaths() adds 1-element-long single-country paths for each country we own in the area, and this function will pick all of those whose country isn't in one of the other paths it picks
      // this is useful in the place armies phase, because those paths are used to arm the border countries
      protected ArrayList pickBestTakeoverPaths(int[] area) {

          ArrayList&lt;int[]&gt; checkPaths = getAreaTakeoverPaths(area); // first, get comprehensive list of paths; this could be thousands of elements long in large cases

          ArrayList&lt;int[]&gt; results = new ArrayList&lt;int[]&gt;(); // this will hold the results, which could be several paths, to include forks and islands
          ArrayList&lt;Integer&gt; countriesLeft = new ArrayList&lt;Integer&gt;(); // list of countries not in any paths we've chosen so far
          // initially populate countriesLeft with every country in area
          for (int i=0; i&lt;area.length; i++) {
                  countriesLeft.add(area[i]);
          }

          testChat(&quot;pickBestTakeoverPaths&quot;, &quot;-- PICK BEST TAKEOVER PATHS --&quot;);

          // now the meat:
          // in each iteration of this loop, we'll pick a new path out of checkPaths to put in the results arraylist.
          // then, if we've already chosen other paths, we'll need to prune the one we just picked of any overlap with them.
          // there should only ever be overlap at the beginning of the new path, in which case it will be a branch of a fork,
          // so we'll want to store the path only the branch point forward (the place armies and attack phase will know how to deal with that).
          // so after we do all that, next we'll prune the list of potential paths (checkPaths) of any whose last element is contained somewhere within one of the results paths we've already chosen.
          // that way, next time around the loop, we're guaranteed to choose a path that ends in a country we haven't covered yet.
          // finally, we'll prune the countriesLeft arraylist of any countries covered in the path we just picked, so that it only contains countries that aren't in any of the paths we've chosen so far.
          // when countriesLeft is empty, we'll know that we've found a comprehensive set of paths to take over the area, so we'll be done with the loop.
          while (countriesLeft.size() &gt; 0) {
              testChat(&quot;pickBestTakeoverPaths&quot;, &quot;-&quot;);

              // find the best single path from the pruned list of paths to check
              int[] newPath = findBestSingleTakeoverPath(checkPaths, area); // see findBestSingleTakeoverPath() for the criteria we use to pick the best path

              // check newPath against all the paths in results to see if it should be a fork of any of them
              // if it should, trim the beginning of the path so that its first element is the branch point
              int[] newPathCut = trimFork(results, newPath);

              // add truncated array to results
              results.add(newPathCut);

              testChat(&quot;pickBestTakeoverPaths&quot;, &quot;-- Paths we're picking:&quot;);
              chatCountryNames(&quot;pickBestTakeoverPaths&quot;, results);

              // prune checkPaths
              // find all paths in checkPaths whose last element is not found anywhere in any chosen path
              // keep those and throw away the rest
              ArrayList&lt;int[]&gt; prunedPaths = new ArrayList&lt;int[]&gt;();
              int checkPathsSize = checkPaths.size();
              for (int i=0; i&lt;checkPathsSize; i++) {
                  boolean isMatch = false;
                  int[] thisCheckPath = checkPaths.get(i); // the path in checkPaths we're testing this loop
                  jLoop: for (int j=0; j&lt;results.size(); j++) { // loop through all the paths in results
                      int[] resultsPath = results.get(j); // the path in results we're checking against this loop
                      for (int k=0; k&lt;resultsPath.length; k++) { // loop through this path in results
                          if (thisCheckPath[thisCheckPath.length-1] == resultsPath[k]) { // if the last element in thisCheckPath is in resultsPath
                              isMatch = true;
                              break jLoop; // move on to next path in checkPaths
                          }
                      }
                  }
                  if (!isMatch) {
                      prunedPaths.add(thisCheckPath);
                  }
              }

              checkPaths = prunedPaths;

              testChat(&quot;pickBestTakeoverPaths&quot;, &quot;-- Pruned list of paths:&quot;);
              chatCountryNames(&quot;pickBestTakeoverPaths&quot;, checkPaths);

              // remove any countries in countriesLeft that are in any of the results paths
              Iterator&lt;Integer&gt; countriesLeftIterator = countriesLeft.iterator();
              while (countriesLeftIterator.hasNext()) { // loop through countriesLeft
                  int thisCountry = countriesLeftIterator.next();
                  iLoop2: for (int i=0; i&lt;results.size(); i++) { // loop through results list
                      int[] thisResult = results.get(i);
                      for (int j=0; j&lt;thisResult.length; j++) { // loop through this result path
                          if (thisResult[j] == thisCountry) { // if this country in countriesLeft is in a results array
                              countriesLeftIterator.remove(); // then remove it from countriesLeft
                              break iLoop2; // and skip to the next country in countriesLeft
                          }
                      }
                  }
              }

              testChat(&quot;pickBestTakeoverPaths&quot;, &quot;-- Pruned version of countriesLeft:&quot;);
              if (countriesLeft.size() &gt; 0) {
                  chatCountryNames(&quot;pickBestTakeoverPaths&quot;, countriesLeft);
              } else {
                  testChat(&quot;pickBestTakeoverPaths&quot;, &quot;[] - no countries in countriesLeft&quot;);
              }
          }

          return results;
      }

      protected int[] trimFork(ArrayList&lt;int[]&gt; checkPlan, int[] pathToTrim) {

          // now we search for a common element with any of the paths we've already chosen
          // if we find one, this will be a branch point (fork), so we'll truncate everything from the new path before the branch point
          int newStart = 0;
          iLoop: for (int i=pathToTrim.length-1; i&gt;=0; i--) { // iterate backwards through pathToTrim
              for (int[] checkPlanPath : checkPlan) { // loop through all the paths we've already picked
                  for (int checkPlanCountry : checkPlanPath) { // loop through this path we've already picked
                      if (pathToTrim[i] == checkPlanCountry) { // if this country in pathToTrim is in one of the old paths
                          newStart = i; // store the index
                          break iLoop; // quit searching
                      }
                  }
              }
          }
          // now truncate the beginning of pathToTrim
          // if we didn't find a branch point, it will not be affected
          int[] trimmed = new int[pathToTrim.length - newStart]; // make new array of appropriate length
          System.arraycopy(pathToTrim, newStart, trimmed, 0, trimmed.length); // copy end of pathToTrim into it

          return trimmed;
      }

      // given a list of takeover paths, pick the longest one
      // if there are multiple longest ones (which there often are),
      // find one that ends on a border and return that one
      // in future versions, we may want to be more sophisticated about which one to choose
      protected int[] findBestSingleTakeoverPath(ArrayList&lt;int[]&gt; paths, int[] area) {
          // find the length of the longest path
          int maxPathLength = 0;
          int size = paths.size();
          for (int i=0; i&lt;size; i++) {
              if (paths.get(i).length &gt; maxPathLength) {
                  maxPathLength = paths.get(i).length;
              }
          }

          // populate a new arraylist with all the longest paths
          ArrayList&lt;int[]&gt; longestPaths = new ArrayList&lt;int[]&gt;();
          for (int i=0; i&lt;size; i++) {
              if (paths.get(i).length == maxPathLength) {
                  longestPaths.add(paths.get(i));
              }
          }

          // pick a path that ends in a border, if there is one
          size = longestPaths.size();
          int pathLength;
          boolean isBorder;
          testChat(&quot;findBestSingleTakeoverPath&quot;, &quot;--- Longest paths: ---&quot;);
          for (int i=0; i&lt;size; i++) {
              pathLength = longestPaths.get(i).length;
              isBorder = isAreaBorder(longestPaths.get(i)[pathLength-1],area);

              String[] countryNames = getCountryNames(longestPaths.get(i));
              testChat(&quot;findBestSingleTakeoverPath&quot;, Arrays.toString(countryNames) + &quot; border? &quot; + isBorder);

              // for now, we'll just return the first one we find that ends in a border
              if (isBorder) {
                  return longestPaths.get(i);
              }
          }

          // if we get here, none of the longest paths ended on a border, so just return the first one
          return longestPaths.get(0);
      }

      // checks to see if country is a border of area by seeing if any of its neighbors is outside of area
      // if the country itself is not in the area, returns false
      protected boolean isAreaBorder (int country, int[] area) {
          // if &lt;country&gt; is not in the area, return false
          if (!isInArray(country, area)) {
              return false;
          }

          int[] neighbors = BoardHelper.getAttackList(countries[country],countries); // countries[country].getAdjoiningCodeList(); // get neighbors
          boolean inArea = false;

          for (int i=0; i&lt;neighbors.length; i++) { // loop through all the country's neighbors
              inArea = false;
              for (int j=0; j&lt;area.length; j++) { // loop through every country in area
                  if (neighbors[i] == area[j]) { // if we found this neighbor in the area
                      inArea = true;
                      break;
                  }
              }
              if (!inArea) { // if inArea is false, then this neighbor is not in the area
                  return true; // which means country is a border, so return true
              }
          }
          return false; // if we got here, all of the neighbors were in area, so country is not a border; return false
      }
      // overloaded version to handle arraylists
      protected boolean isAreaBorder(int country, ArrayList&lt;Integer&gt; list) {
          return isAreaBorder(country, convertListToIntArray(list));
      }

      // returns an int[] of all the borders of the given area
      protected int[] getAreaBorders(int[] area) {
          ArrayList&lt;Integer&gt; borders = new ArrayList&lt;Integer&gt;();

          for (int i=0; i&lt;area.length; i++) {
              if (isAreaBorder(area[i],area)) {
                  borders.add(area[i]);
              }
          }

          int[] bordersArray = new int[borders.size()];
          for (int i=0; i&lt;bordersArray.length; i++) {
              bordersArray[i] = borders.get(i);
          }

          return bordersArray;
      }
      // overloaded version to handle arraylists
      protected int[] getAreaBorders(ArrayList&lt;Integer&gt; list) {
          return getAreaBorders(convertListToIntArray(list));
      }

      // find all possible paths through enemy countries within countryList
      // starting with the last country in the history array
      // history is an array of country codes containing the path history already searched
      // countryList is an array of country codes in which the entire search takes place
      // this may typically be a continent, but doesn't have to be
      // returns an ArrayList of paths (which are integer arrays)
      // the function calls itself recursively
      protected ArrayList findAreaPaths(int[] history, int[] countryList) {
          ArrayList&lt;int[]&gt; terminalPaths = new ArrayList&lt;int[]&gt;(); // all possible terminal paths will end up in this array
          int startCountry = history[history.length - 1]; // starting country is the last element in the history
          int[] newHistory = new int[history.length + 1]; // new history array to add the next country(s) to
          System.arraycopy(history, 0, newHistory, 0, history.length); // copy the old history into the beginning of new history, leaving one empty spot at the end
          int[] neighbors = countries[startCountry].getAdjoiningCodeList(); // get list of startCountry's neighbors
          boolean anyValidNeighbors = false; // if we find any valid neighbors, we'll switch this to true

          // check the global variable &lt;pathCount&gt;, which stores the total number of paths we've already created;
          // if we've already got a hundred thousand of them, we want to stop looking to save time (and memory);
          // if we didn't find everything, it's okay, because getAreaTakeoverPaths() will take stock of
          // what's missing, and call findAreaPaths() again on whatever's leftover
          if (pathCount &gt;= 100000) {
              return terminalPaths;
          }

          // loop through all neighbors; if valid, add to history and recurse
          for (int i=0; i&lt;neighbors.length; i++) {
              if (pathNeighborIsValid(neighbors[i], history, countryList)) { // if the country is valid
                  anyValidNeighbors = true;
                  newHistory[newHistory.length-1] = neighbors[i]; // add it to the end of the new history
                  terminalPaths.addAll(findAreaPaths(newHistory, countryList)); // recurse, adding whole chain to the terminalPaths array
              }
          }

          // if there were no valid neighbors, we're at the end of the path
          // the history as given includes the terminal country of the path
          // so all we have to do is send back the history we were given, wrapped in an arrayList
          // (we'll add it to terminalPaths, which should be empty in this case)
          // and as it bubbles up, it will be concatenated with any other terminal paths that were found
          // in other branches
          if (anyValidNeighbors == false) {
              // make a copy of history to add to terminalPaths to avoid reference/scope problem
              int[] historyCopy = new int[history.length];
              System.arraycopy(history, 0, historyCopy, 0, history.length);

              // since we're adding a terminal path here, increment &lt;pathCount&gt;
              // which keeps track of the total number of paths we have
              pathCount++;

              // add the path
              terminalPaths.add(historyCopy);
          }

          // return the terminalPaths arrayList. if we're at the end of a path, this will contain
          // a single terminal path. If we're not at the end of a path, it will contain all the terminal
          // paths below us that were found recursively, which will then be concatenated with any other
          // terminal paths that were found elsewhere (i.e. the branches that split above us) as they bubble up
          return terminalPaths;
      }

      //given a list of countries, clump the countries into all possible contiguous areas
      protected ArrayList findContiguousAreas(int[] countryArray) {
          ArrayList&lt;int[]&gt; contiguousAreaList = new ArrayList&lt;int[]&gt;();
          ArrayList&lt;Integer&gt; countryList = new ArrayList&lt;Integer&gt;();
          for (int country : countryArray) { countryList.add(country); }

          // loop through the master &lt;countryList&gt;
          while (countryList.size() &gt; 0) {

              ArrayList&lt;Integer&gt; thisClump = new ArrayList&lt;Integer&gt;(); // will be populated with this clump of contiguous countries
              thisClump.add(countryList.get(0)); // add the country we're on to the clump
              countryList.remove(0); // then remove it from the master list

              // now we'll find all the neighbors of the initial country,
              // and if any of them are in &lt;countryList&gt;, we'll add them to the end of the &lt;thisClump&gt; list
              // and remove them from &lt;countryList&gt;;
              // since we added them to &lt;thisClump&gt;, we'll then run into them on subsequent iterations
              // of the for loop and check their neighbors as well in the same fashion;
              // this loop will end when no more countries in it have neighbors that are in &lt;countryList&gt;
              // at which point we know we'll have an exhaustive &quot;clump&quot; of contiguous countries,
              // and then we'll put it into our results list &lt;contiguousAreaList&gt;
              // and move on to the next country in the master list
              for(int country=0; country&lt;thisClump.size(); country++) { // loop through the countries in this clump
                  int[] neighbors = countries[thisClump.get(country)].getAdjoiningCodeList(); // get neighbors of this country
                  for (int neighbor : neighbors) { // loop through neighbors
                      if (isInArray(neighbor,countryList)) { // if neighbor is in countryList, we haven't seen it yet,
                          thisClump.add(neighbor); // so add neighbor to thisClump
                          countryList.remove((Integer) neighbor); // and remove it from countryList
                      }
                  }
              }

              // add &lt;thisClump&gt; to the results list
              contiguousAreaList.add(convertListToIntArray(thisClump));
          }

          return contiguousAreaList;
      }

      // called by the findAreaPaths function to determine whether a potential country in a path is valid
      // i.e. we don't own it, it hasn't been visited already, and it's in the specified list of countries (e.g. a certain continent)
      protected boolean pathNeighborIsValid(int neighbor, int[] history, int[] countryList) {

          // first check if we own the country using getProjectedCountryOwner();
          // importantly, we're checking if we actually own the country right now,
          // but we're also treating it as though we own it if it's in a path that's already in &lt;battlePlan&gt;;
          // in other words, if we're already planning to take over a country this turn (for some other purpose)
          // we're going to treat it as though we own it here; that way the paths we're finding here
          // will take into account the paths we will have already taken over by the time we get to them
          if (getProjectedCountryOwner(neighbor) == ID) {
              return false; // if we own it, it's invalid, so return false immediately
          }

          // next, check if the neighbor has already been visited (i.e. it's in the history)
          // it's probably faster to iterate backwards from the end of the array, since a neighbor
          // we've already visited is more likely to be near the end of the array
          for (int i=history.length-1; i&gt;=0; i--) {
              if (history[i] == neighbor) {
                  return false; // if in history, it's invalid, so return false immediately
              }
          }

          // check if the neighbor is in the allowed list of countries
          for (int i=0; i&lt;countryList.length; i++) {
              if (countryList[i] == neighbor) {
                  return true; // if we've gotten this far, all the other checks have passed, so return true
              }
          }

          // return false by default. We'll get here in one of two cases I can think of:
          // (1) it's an enemy country that's not in the history and is also not in the countryList, or
          // (2) it's not a country. In case we get passed values that aren't countries, they should be deemed invalid
          return false;
      }

      // method to concatenate integer arrays
      // THIS METHOD HASN'T BEEN TESTED YET!
      protected int[] arrayConcat(int[] a, int[] b) {
          int aLength = a.length;
          int bLength = b.length;
          int[] c= new int[aLength + bLength];
          System.arraycopy(a, 0, c, 0, aLength);
          System.arraycopy(b, 0, c, aLength, bLength);
          return c;
      }

      // takes an integer array of continent codes and returns a string array of the associated continent names
      // useful for testing purposes
      protected String[] getContinentNames(int[] codes) {
          int size = codes.length;
          String[] names = new String[size];
          for (int i=0; i&lt;size; i++) {
              names[i] = board.getContinentName((Integer) codes[i]).replace(&quot;,&quot;,&quot;&quot;); // get rid of commas in country names because that's confusing when we output the whole array as a string
          }
          return names;
      }

      // takes an integer array of country codes and returns a string array of the associated country names
      // useful for testing purposes
      protected String[] getCountryNames(int[] codes) {
          int size = 0;
          try {
              size = codes.length;
          } catch (NullPointerException e) {
              System.err.println(&quot;Viking says: NullPointerException: &quot; + e.getMessage());
              e.printStackTrace();
              return new String[]{&quot;[error: null]&quot;};
          }
          String[] names = new String[size];
          for (int i=0; i&lt;size; i++) {
              names[i] = countries[codes[i]].getName().replace(&quot;,&quot;,&quot;&quot;); // get rid of commas in country names because that's confusing when we output the whole array as a string
          }
          return names;
      }
      // overloaded version to handle arraylists instead of arrays
      protected String[] getCountryNames(ArrayList&lt;Integer&gt; list) {
          return getCountryNames(convertListToIntArray(list));
      }

      // return the name of a country code
      protected String getCountryName(int code) {
          String name;
          if (code &gt;= 0 &amp;&amp; code &lt; countries.length) {
              name = countries[code].getName().replace(&quot;,&quot;,&quot;&quot;); // get rid of commas in country name
          } else {
              name = &quot;&quot; + code;
          }
          return name;
      }

      // chat a list of countries by name, given an array of country codes
      // callingFunc is simply a string to give to the testChat() function to tell it where the chatting is coming from; see testChat() for details
      // useful for testing purposes
      protected void chatCountryNames(String callingFunc, int[] codes) {
          if (codes.length &lt; 1) { return; } // if we're passed an empty array, simply do nothing
          String[] countryNames = getCountryNames(codes);
          testChat(callingFunc, Arrays.toString(countryNames));
      }
      // chat a list, either of arrays of countries (the usual case), or simply of countries (unusual)
      // converting, in both cases, the country codes to country names
      // **NOTE!** this function assumes that all the elements of list are the same type. It may act unexpectedly if they are not
      // callingFunc is simply a string to give to the testChat() function to tell it where the chatting is coming from; see testChat() for details
      // useful for testing purposes
      protected void chatCountryNames(String callingFunc, ArrayList list) {
          if (list.size() &lt; 1) { return; } // if we're passed an empty ArrayList, simply do nothing
          // if the first element in list is an int[], we'll assume they all are, and this is a list of paths
          // so we'll loop through list and chat out each path separately
          if (list.get(0) instanceof int[]) {
              for(int i=0; i&lt;list.size(); i++) {
                  if (list.get(i) instanceof int[]) {
                      int[] codesArray = (int[]) list.get(i);
                      chatCountryNames(callingFunc, codesArray);
                  }
              }
          }
          // if the first element in list is an integer, we'll assume they all are, and this is a list of countries
          // so we'll convert list into an int[], and chat it out all at once
          if (list.get(0) instanceof Integer) {
              // first convert the ArrayList into an int[] array
              int[] codesArray = new int[list.size()];
              for (int i=0; i&lt;codesArray.length; i++) {
                  if (list.get(i) instanceof Integer) {
                      codesArray[i] = (Integer) list.get(i);
                  } else {
                      codesArray[i] = -1;
                  }
              }
              // then call chatCountryNames using the int[] array
              chatCountryNames(callingFunc, codesArray);
          }
      }

      // function to chat Objectives for testing purposes
      // objectives are hashmaps of an attack plan and other information for taking over areas or knocking out bonuses or what have you
      protected void chatObjectives(String callingFunc, HashMap&lt;String, Object&gt; objective) {
          String message = new String();
          for (String key : objective.keySet()) {
              Object value = objective.get(key);
              String stringValue = objectToString(value);

              if (key == &quot;continentID&quot;) {
                  message += &quot;continent: &quot; + board.getContinentName((Integer) value) + &quot;\n&quot;;
              } else if (key == &quot;continentIDs&quot;) {
                  message += &quot;continents: &quot; + Arrays.toString(getContinentNames((int[]) value)) + &quot;\n&quot;;
              } else {
                  message += key + &quot;: &quot; + stringValue + &quot;\n&quot;;
              }
          }

          testChat(callingFunc, message);
      }
      // overloaded version to handle arraylists of Objectives
      protected void chatObjectives(String callingFunc, ArrayList&lt;HashMap&gt; list) {
          for (HashMap objective : list) {
              chatObjectives(callingFunc, objective);
          }
      }

      // convert a number of different types to String
      // if it can't convert that type, return null
      // this is useful for outputting various values in testing
      protected String objectToString(Object value) {
          if (value instanceof String) {
              return (String) value;
          }
          if (value instanceof Integer || value instanceof Float) {
              return &quot;&quot; + value;
          }
          if (value instanceof int[]) {
              return Arrays.toString(getCountryNames((int[]) value));
          }
          if (value instanceof ArrayList) {
              String listString = new String();
              for (Object element : (ArrayList) value) { // loop through the list
                  listString += objectToString(element) + &quot;\n&quot;; // recurse on each element, converting it to a string, whatever type it is
              }
              return listString;
          }

          return &quot;&quot;;
      }

      // helper function to return an array of the countries a player owns in a given continent
      // player is the player ID to check; cont is the continent in question
  /*    protected int[] getPlayerCountriesInContinent(int cont, int player) {
          // continent iterator returns all countries in 'cont',
          // player iterator returns all countries out of those owned by 'player'
          // this gives us the list of all the countries we own in the continent
          CountryIterator theCountries = new PlayerIterator(player, new ContinentIterator(cont, countries));

          // Put all the countries we own into an ArrayList
          ArrayList countryArray = new ArrayList();
          while (theCountries.hasNext()) {
              countryArray.add(theCountries.next());
          }

          // Put the country code of each of the countries into an integer array
          int size = countryArray.size();
          int[] intArray = new int[size];
          for(int i=0; i &lt; size; i++) {
              intArray[i] = ((Country)countryArray.get(i)).getCode();
          }

          return intArray;
      }
      // overloaded version: if no player is provided, assume it should be us
      protected int[] getPlayerCountriesInContinent(int cont) {
          return getPlayerCountriesInContinent(cont, ID);
      }*/

      // returns the country code of the weakest enemy country that this country can attack,
      // preferring the one owned by the strongest enemy in the event of a tie;
      // if a neighbor is in &lt;blacklist&gt;, it's ineligible; this function is used for pathfinding, so the blacklist functions as a history of countries already chosen
      // if there are no enemy neighbors, returns -1
      protected int findWeakestNeighborOwnedByStrongestEnemy(int country, ArrayList&lt;Integer&gt; blacklist) {
          int[] neighbors = countries[country].getAdjoiningCodeList(); // get array of neighbors
          ArrayList&lt;Integer&gt; enemyNeighbors = new ArrayList&lt;Integer&gt;();

          // loop through all the neighbors, adding all enemy neighbors to the &lt;enemyNeighbors&gt; list
          for (int neighbor : neighbors) { // loop through all neighbors
              // if &lt;country&gt; can attack into &lt;neighbor&gt; and we don't own (or plan to own) &lt;neighbor&gt; and it isn't in the blacklist
              if (countries[country].canGoto(neighbor) &amp;&amp; getProjectedCountryOwner(neighbor) != ID &amp;&amp; !isInArray(neighbor, blacklist)) {
                  enemyNeighbors.add(neighbor); // then add it to the list of enemy neighbors
              }
          }

  //        testChat(&quot;findWeakestNeighborOwnedByStrongestEnemy&quot;, &quot;Enemy neighbors of &quot; + getCountryName(country) + &quot;:&quot;);
  //        chatCountryNames(&quot;findWeakestNeighborOwnedByStrongestEnemy&quot;, enemyNeighbors);

          // remove all but the weakest enemy neighbors from the list;
          // first, loop through the list once to find the least number of armies on any of the countries;
          // then loop again to remove any countries that have more armies than that
          int leastArmies = Integer.MAX_VALUE; // initially set &lt;leastArmies&gt; to the highest possible value
          for (int neighbor : enemyNeighbors) { // loop over neighbors
              int armies = countries[neighbor].getArmies(); // the number of armies on this country
              if (armies &lt; leastArmies) { // if there are fewer armies on this country than &lt;leastArmies&gt;
                  leastArmies = armies; // set &lt;leastArmies&gt; to this country's number of armies
              }
          }
          ListIterator&lt;Integer&gt; iter = enemyNeighbors.listIterator(enemyNeighbors.size());
          while (iter.hasPrevious()) { // iterating backwards over the list should be faster when removing elements
              int neighbor = iter.previous(); // this country
              int armies = countries[neighbor].getArmies(); // this country's number of armies
              if (armies &gt; leastArmies) { // if this country has more armies than the weakest neighbor
                  iter.remove(); // remove it
              }
          }

  //        testChat(&quot;findWeakestNeighborOwnedByStrongestEnemy&quot;, &quot;Weakest enemy neighbors of &quot; + getCountryName(country) + &quot;:&quot;);
  //        chatCountryNames(&quot;findWeakestNeighborOwnedByStrongestEnemy&quot;, enemyNeighbors);

          // now we should have a list of all of only the weakest enemy neighbors;
          // so we just need to find a country owned by the strongest player
          int chosenCountry = -1;
          int highestIncome = Integer.MIN_VALUE; // we don't want to use 0 here, because it might be (???) technically possible for everyone to have a negative income if there are negative continent bonuses; although the game probably keeps the minimum at 3, I'm not sure
          for (int neighbor : enemyNeighbors) { // loop through the list of weakest neighbors
              int income = board.getPlayerIncome(countries[neighbor].getOwner()); // the income of the player that owns this country
              if (income &gt; highestIncome) { // if it's higher than the highest one we've seen so far
                  chosenCountry = neighbor; // choose this country
                  highestIncome = income; // this is the new highest income we've seen
              }
          }

  //        testChat(&quot;findWeakestNeighborOwnedByStrongestEnemy&quot;,&quot;Weakest neighbor owned by strongest enemy: &quot; + getCountryName(chosenCountry));

          // return the chosen country
          // if the list of enemy neighbors was empty, this value will be -1
          return chosenCountry;
      }
      // overloaded version to allow the function to be called without a blacklist;
      // just passes a dummy arraylist as the blacklist parameter
      protected int findWeakestNeighborOwnedByStrongestEnemy(int country) {
          return findWeakestNeighborOwnedByStrongestEnemy(country, new ArrayList&lt;Integer&gt;());
      }

      // returns the country code of an enemy country that this country can attack,
      // preferring ones with few armies and many enemy neighbors, with much more weight assigned to army count
      // (in the event of a tie, it chooses the one owned by the strongest enemy);
      // if a neighbor is in &lt;blacklist&gt;, it's ineligible; this function is used for pathfinding, so the blacklist functions as a history of countries already chosen
      // if there are no enemy neighbors, returns -1
      protected int findWeakestNeighborWithMostEnemyNeighbors(int country, ArrayList&lt;Integer&gt; blacklist) {
          String testMessage = &quot;Neighbors of &quot; + getCountryName(country) + &quot;: &quot;;

          int[] neighbors = countries[country].getAdjoiningCodeList(); // get array of neighbors
          ArrayList&lt;Integer&gt; promisingNeighbors = new ArrayList&lt;Integer&gt;(); // will contain the best neighbors (the weakest neighbors with the most enemy neighbors)

          // find the best neighbor(s), as scored by the number of its neighbors, divided by its armies to the tenth power
          // and add them to the promisingNeighbors array list
          double maxScore = 0;
          for (int neighbor : neighbors) { // loop through all neighbors

              // if &lt;country&gt; can attack into &lt;neighbor&gt; and we don't own (or plan to own) &lt;neighbor&gt; and it isn't in the blacklist
              if (countries[country].canGoto(neighbor) &amp;&amp; getProjectedCountryOwner(neighbor) != ID &amp;&amp; !isInArray(neighbor, blacklist)) {
                  int[] adjoiningList = countries[neighbor].getAdjoiningCodeList(); // get the neighbors of this neighbor
                  double numAdjoining = 0;
                  for (int adjoining : adjoiningList) { // loop through this neighbor's neighbors to count them
                      // if this neighbor is valid (&lt;neighbor&gt; can attack it, we don't own it, and it's not in the blacklist)
                      if (countries[neighbor].canGoto(adjoining) &amp;&amp; getProjectedCountryOwner(adjoining) != ID &amp;&amp; !isInArray(adjoining, blacklist)) {
                          // then count the adjoining country
                          // if the adjoining country is owned by an ally, however,
                          // we want to count it less, to weakly discourage taking over allies
                          // so we only count it as a third, instead of a whole country
                          numAdjoining += 1.0f / (isAlly(countries[adjoining].getOwner()) ? 3.0f : 1.0f);
                      }
                  }

                  testMessage += getCountryName(neighbor) + &quot; (&quot; + numAdjoining + &quot;), &quot;;

                  // now score this neighbor
                  double score = (double) numAdjoining/(double) Math.pow(countries[neighbor].getArmies(), 10);

                  // if this neighbor's score is the highest we've seen
                  if (score &gt; maxScore) {
                      // save this as the new highest score
                      maxScore = score;

                      // clear any others we've saved so far,
                      // because we only want to save the highest score (and any that tie it)
                      // and then save this one
                      promisingNeighbors.clear();
                      promisingNeighbors.add(neighbor);
                  } else if (score == maxScore) {
                      // if this neighbor's score is tied with the highest we've seen so far
                      // save it along with the others we've saved so far, without deleting them
                      promisingNeighbors.add(neighbor);
                  }
              }
          }

          testChat(&quot;findWeakestNeighborWithMostEnemyNeighbors&quot;,testMessage);
          testChat(&quot;findWeakestNeighborWithMostEnemyNeighbors&quot;, &quot;Promising neighbors of &quot; + getCountryName(country) + &quot;: &quot; + Arrays.toString(getCountryNames(promisingNeighbors)));

          // now, in case we have any ties, we'll pick the neighbor
          // that's owned by the strongest enemy
          int chosenCountry = -1; // if there were no neighbors, this will remain -1
          int highestIncome = Integer.MIN_VALUE; // we don't want to use 0 here, because it might be (???) technically possible for everyone to have a negative income if there are negative continent bonuses; although the game probably keeps the minimum at 3, I'm not sure
          for (int neighbor : promisingNeighbors) { // loop through the list of weakest neighbors
              int income = board.getPlayerIncome(countries[neighbor].getOwner()); // the income of the player that owns this country
              if (income &gt; highestIncome) { // if it's higher than the highest one we've seen so far
                  chosenCountry = neighbor; // choose this country
                  highestIncome = income; // this is the new highest income we've seen
              }
          }

          // if there were no valid neighbors at all, this will return -1
          return chosenCountry;
      }
      // overloaded version to allow the function to be called without a blacklist;
      // just passes a dummy arraylist as the blacklist parameter
      protected int findWeakestNeighborWithMostEnemyNeighbors(int country) {
          return findWeakestNeighborWithMostEnemyNeighbors(country, new ArrayList&lt;Integer&gt;());
      }

      // return array of countries (projected to be) owned by &lt;player&gt;
      protected int[] getPlayerCountries(int player) {
          ArrayList&lt;Integer&gt; ownedCountries = new ArrayList&lt;Integer&gt;();
          for (int i=0; i&lt;countries.length; i++) {
              if (getProjectedCountryOwner(i) == player) {
                  ownedCountries.add(i);
              }
          }
          return convertListToIntArray(ownedCountries);
      }
      // overloaded version: if no player is supplied, assume it should be us
      protected int[] getPlayerCountries() {
          return getPlayerCountries(ID);
      }

      // helper function to return an array of the countries a player owns in a given list of countries (area)
      // player is the player ID to check; area is the list of countries to search in
      protected int[] getPlayerCountriesInArea(int[] area, int player) {
          // loop through all the countries in area; if player owns them, add them to the results ArrayList
          List&lt;Integer&gt; results = new ArrayList&lt;Integer&gt;();
          for (int i=0; i&lt;area.length; i++) {
              // if the player is us, we need to check for projected ownership (if we own it or if we plan to)
              //&nbsp;if it's not us, just check for ownership the regular way
              if ((player == ID &amp;&amp; getProjectedCountryOwner(area[i]) == ID) || countries[area[i]].getOwner() == player) {
                  results.add(area[i]);
              }
          }

          // Put the country code of each of the countries into an integer array
          int size = results.size();
          int[] intArray = new int[size];
          for(int i=0; i &lt; size; i++) {
              intArray[i] = results.get(i).intValue();
          }

          return intArray;
      }
      // overloaded version: if no player is provided, assume it should be us
      protected int[] getPlayerCountriesInArea(int[] area) {
          return getPlayerCountriesInArea(area, ID);
      }

      // helper function to return an array of the countries in a given continent
      protected int[] getCountriesInContinent(int cont) {
          // continent iterator returns all countries in 'cont'
          CountryIterator theCountries = new ContinentIterator(cont, countries);

          // Put all the countries into an ArrayList
          ArrayList countryArray = new ArrayList();
          while (theCountries.hasNext()) {
              countryArray.add(theCountries.next());
          }

          // Put the country code of each of the countries into an integer array
          int size = countryArray.size();
          int[] intArray = new int[size];
          for(int i=0; i&lt;size; i++) {
              intArray[i] = ((Country)countryArray.get(i)).getCode();
          }

          return intArray;
      }

      // helper function to return an array of the countries a player does not own in a given continent
      protected int[] getForeignCountriesInContinent(int owner, int cont) {
          // get all the countries in the continent
          int[] theCountries = getCountriesInContinent(cont);
          // return getForeignCountriesInArea on the list of countries
          return getForeignCountriesInArea(theCountries, owner);
      }

      // helper function to return an array of the countries a player does not own in a given area
      protected int[] getForeignCountriesInArea(int[] area, int owner) {
          // add all the countries not owned by owner to a new array list
          ArrayList&lt;Integer&gt; countryList = new ArrayList&lt;Integer&gt;();
          for (int country : area) {
              if (getProjectedCountryOwner(country) != owner) {
                  countryList.add(country);
              }
          }

          // copy the array list of enemy countries to an integer array
          int size = countryList.size();
          int[] results = new int[size];
          for(int i=0; i&lt;size; i++) {
              results[i] = countryList.get(i);
          }

          // return the integer array of enemy countries
          return results;
      }
      // overloaded version; if no owner ID is provided, assume it is us
      protected int[] getForeignCountriesInArea(int[] area) {
          return getForeignCountriesInArea(area, ID);
      }

      //returns true if &lt;player&gt; is an enemy, i.e. not self and not an ally.
      protected boolean isEnemy(int player) {
          if  (player != ID &amp;&amp; !isAlly(player)) {
             return true;
          }
          return false;
      }

      //returns true if &lt;player&gt; is an ally.
      protected boolean isAlly(int player) {
         if (isInArray(player, allies)) {
            return true;
         }
         return false;
      }

      // returns true if &lt;player&gt; owns every country in &lt;area&gt;
      protected boolean playerOwnsArea(int[] area, int player) {
          for (int country : area) {
              if (getProjectedCountryOwner(country) != player) {
                  return false;
              }
          }
          return true;
      }
      // overloaded single-parameter version assumes &quot;player&quot; is us
      protected boolean playerOwnsArea(int[] area) {
          return playerOwnsArea(area, ID);
      }

      // helper function to return the summary magnitude of all continent bonuses completely contained within &lt;area&gt;
      // we should never have duplicate countries in an area,
      // but note that this function will not work if there are duplicate countries
      protected int getAreaBonuses(int[] area) {
          testChat(&quot;getAreaBonuses&quot;, &quot;--- Get Area Bonuses ---&quot;);
          chatCountryNames(&quot;getAreaBonuses&quot;, area);

          int totalBonus = 0;

          // create an array of the number of &lt;area&gt; countries in each continent,
          // where the indices of the list are the continent codes,
          // and the values are the number of &lt;area&gt; countries in that continent
          int[] contPopulations = new int[numConts];
          for (int i=0; i&lt;contPopulations.length; i++) {
              contPopulations[i] = 0; // initially populate the whole list with 0
          }
          for (int country : area) { // loop through area to populate &lt;contPopulations&gt;
              int continent = countries[country].getContinent(); // the continent this country is in
              if (continent &gt;= 0) { // if the country is part of a continent
                  contPopulations[continent] += 1; // add 1 to &lt;contPopulations&gt; for this continent
              }
          }

          String message = &quot;Countries in continents: \n&quot;;
          for (int i=0; i&lt;contPopulations.length; i++) {
              message += board.getContinentName(i) + &quot;: &quot;;
              message += contPopulations[i] + &quot;\n&quot;;
          }
          testChat(&quot;getAreaBonuses&quot;, message);

          testChat(&quot;getAreaBonuses&quot;, &quot;Continents completely covered by area: &quot;);

          // now we loop through &lt;contPopulations&gt;, and check each value
          // against the total number of countries that continent contains
          // and if &lt;area&gt; has every country in it, add its bonus to &lt;totalBonus&gt;
          for (int continent=0; continent&lt;contPopulations.length; continent++) {
              int size = BoardHelper.getContinentSize(continent, countries);
              if (contPopulations[continent] == size) { // if &lt;area&gt; has all the countries in this continent

                  testChat(&quot;getAreaBonuses&quot;, board.getContinentName(continent));

                  totalBonus += board.getContinentBonus(continent); // add this continent's bonus to &lt;totalBonus&gt;
              }
          }

          testChat(&quot;getAreaBonuses&quot;, &quot;Total bonus: &quot; + totalBonus);

          return totalBonus;
      }

      // helper function to return an array of all continent codes completely contained within &lt;area&gt;
      // we should never have duplicate countries in an area,
      // but note that this function will not work if there are duplicate countries
      protected int[] getAreaContinentIDs(int[] area) {
          testChat(&quot;getAreaContinentIDs&quot;, &quot;--- Get Area Continent ID's ---&quot;);
          chatCountryNames(&quot;getAreaContinentIDs&quot;, area);

          ArrayList&lt;Integer&gt; contCodes = new ArrayList&lt;Integer&gt;();

          // create an array of the number of &lt;area&gt; countries in each continent,
          // where the indices of the list are the continent codes,
          // and the values are the number of &lt;area&gt; countries in that continent
          int[] contPopulations = new int[numConts];
          for (int i=0; i&lt;contPopulations.length; i++) {
              contPopulations[i] = 0; // initially populate the whole list with 0
          }
          for (int country : area) { // loop through area to populate &lt;contPopulations&gt;
              int continent = countries[country].getContinent(); // the continent this country is in
              if (continent &gt;= 0) { // if the country is part of a continent
                  contPopulations[continent] += 1; // add 1 to &lt;contPopulations&gt; for this continent
              }
          }

          String message = &quot;Countries in continents: \n&quot;;
          for (int i=0; i&lt;contPopulations.length; i++) {
              message += board.getContinentName(i) + &quot;: &quot;;
              message += contPopulations[i] + &quot;\n&quot;;
          }
          testChat(&quot;getAreaContinentIDs&quot;, message);

          testChat(&quot;getAreaContinentIDs&quot;, &quot;Continents completely covered by area: &quot;);

          // now we loop through &lt;contPopulations&gt;, and check each value
          // against the total number of countries that continent contains
          // and if &lt;area&gt; has every country in it, add it to &lt;contCodes&gt;
          for (int continent=0; continent&lt;contPopulations.length; continent++) {
              int size = BoardHelper.getContinentSize(continent, countries);
              if (contPopulations[continent] == size) { // if &lt;area&gt; has all the countries in this continent

                  testChat(&quot;getAreaContinentIDs&quot;, board.getContinentName(continent));

                  contCodes.add(continent); // add this continent to &lt;contCodes&gt;
              }
          }

          // transfer &lt;contCodes&gt; arraylist to an int[] array to return
          int[] results = new int[contCodes.size()];
          for (int i=0; i&lt;contCodes.size(); i++) {
              results[i] = contCodes.get(i);
          }

          return results;
      }

      // when passed an area, will see if it can reduce the number of borders
      // that have to be defended by adding countries to the area (but not removing any)
      // returns a new area with the added countries included
      protected int[] getSmartBordersArea(int[] originalArea) {
          // testing stuff
          String areaName = board.getContinentName(getAreaContinentIDs(originalArea)[0]);
          testChat(&quot;getSmartBordersArea&quot;, &quot;========== SMART BORDERS FOR &quot; + areaName + &quot; ==========&quot;);

          // we'll create a number of candidate areas by adding increasing numbers of layers
          // to the outside of the original area and pruning them back
          // (at the end we'll pick the candidate with the smallest number of borders)
          ArrayList&lt;ArrayList&lt;Integer&gt;&gt; candidateAreas = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();

          // the number of layers to test out to
          // e.g. if the depth is 2, the first candidate layer will simply be the original area
          // the second candidate area will be with 1 layer of countries added and then pruned,
          // and the final candidate area will be with 2 layers of countries added and then pruned
          int depth = 2;

          // add the original area to &lt;candidateAreas&gt; as the initial candidate area
          ArrayList&lt;Integer&gt; originalAreaList = new ArrayList&lt;Integer&gt;();
          for (int country : originalArea) { originalAreaList.add((Integer) country); }
          candidateAreas.add(originalAreaList);

          // new countries we're adding to the area to be pruned
          // this list will grow with each loop so that the layers are cumulative
          // in other words, the pruning at depth 2, for example, will operate on both the first and second layer
          ArrayList&lt;Integer&gt; addedCountries = new ArrayList&lt;Integer&gt;();

          // loop from 1 to &lt;depth&gt;, creating a candidate area of depth &lt;layer&gt; on each loop and adding it to &lt;candidateAreas&gt;
          for (int layer=1; layer&lt;=depth; layer++) {
              testChat(&quot;getSmartBordersArea&quot;,&quot;***** &quot; + layer + &quot; layers out: *****&quot;);

              // create list of original area plus all the layers we found on previous loops
              // and find its borders so that we can create the new layer
              ArrayList&lt;Integer&gt; lastLayerArea = new ArrayList&lt;Integer&gt;(originalAreaList);
              lastLayerArea.addAll(addedCountries);
              int[] lastLayerBorders = getAreaBorders(lastLayerArea);

              // create new layer
              // add all the countries one layer out from each border country to &lt;addedCountries&gt;, ignoring duplicates
              for (int country : lastLayerBorders) { // loop through original borders
                  int[] neighbors = BoardHelper.getAttackList(countries[country], countries); // get neighbors of this border country
                  for (int neighbor : neighbors) { // loop through each neighbor
                      if (!isInArray(neighbor,originalAreaList) &amp;&amp; !isInArray(neighbor, addedCountries)) { // if this neighbor is not in the original area or in any of the new layers (including the one we're creating now&mdash;we don't want duplicates)
                          addedCountries.add(neighbor); // add it to &lt;addedCountries&gt;
                      }
                  }
              }
              testChat(&quot;getSmartBordersArea&quot;, &quot;    New layer: &quot; + Arrays.toString(getCountryNames(addedCountries)));

              // then we will prune off any countries that are only touching one or fewer non-border countries in the new area;
              candidateAreas.add(pruneAreaAddedCountries(originalAreaList, addedCountries));

              // temporary crap for testing purposes
              int oldNumBorders = getAreaBorders(originalArea).length;
              ArrayList&lt;Integer&gt; prunedAdditions = (ArrayList&lt;Integer&gt;) candidateAreas.get(candidateAreas.size()-1).clone();
              int newNumBorders = getAreaBorders(prunedAdditions).length;
              prunedAdditions.removeAll(originalAreaList);
              testChat(&quot;getSmartBordersArea&quot;, &quot;    Pruned layer: &quot; + (prunedAdditions.size() &gt; 0 ? Arrays.toString(getCountryNames(prunedAdditions)) : &quot;[none]&quot;));
              testChat(&quot;getSmartBordersArea&quot;,&quot;    New borders: &quot; + newNumBorders + &quot;, Original borders: &quot; + oldNumBorders);
          }

          // now pick the candidate area with the fewest borders (favoring the lower-layer areas in the case of ties)
          ArrayList&lt;Integer&gt; pickedArea = new ArrayList&lt;Integer&gt;();
          int minBorders = Integer.MAX_VALUE;
          int numOriginalBorders = getAreaBorders(originalArea).length; // number of borders of original area
          int numOriginalCountries = originalArea.length;
          int pickedLayer = -1; // (just for testing purposes)
          String message = &quot;ratios -- &quot;; // just for testing purposes
          for(int i=0; i&lt;candidateAreas.size(); i++) { // loop through all the candidate areas
              int numBorders = getAreaBorders(candidateAreas.get(i)).length; // the number of borders this area has
              if (numBorders &lt; minBorders) { // if this area has the least borders so far
                  int numCountries = candidateAreas.get(i).size(); // the number of countries in the proposed new area
                  // now we'll check if it's worth adding the number of countries proposed to get the resulting reduction in borders;
                  // if the following ratio is less than 1.1, we subjectively deem that it's worth it
                  // i.e. if the border reduction is small and the number of countries we have to add is large, it's not worth doing
                  // the ratio of the original area is always 1.0, so if all of the proposed new areas fail here, we'll revert to the original
                  // (so don't ever change this ratio to less than 1.0, or it will break)
                  float ratio = ((float) numBorders / (float) numOriginalBorders) / ((float) numOriginalCountries / (float) numCountries);

                  message += i + &quot; layer: &quot; + ratio + &quot;, &quot;; // testing purposes

                  if (ratio &lt; 1.1f) {
                      minBorders = numBorders; // set &lt;minBorders&gt; to this areas number of borders
                      pickedArea = candidateAreas.get(i); // pick it
                      pickedLayer = i; // (just for testing purposes)
                  }
              }
          }

          testChat(&quot;getSmartBordersArea&quot;, message);
          testChat(&quot;getSmartBordersArea&quot;, &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Picking layer &quot; + pickedLayer + &quot; version&quot;);
          testChat(&quot;getSmartBordersArea&quot;,&quot;&quot;);

          // convert the area we picked to an int[] and return it
          return convertListToIntArray(pickedArea);
      }

      // called by getSmartBordersArea()
      // the aforementioned function takes a given area and finds layers of countries around it;
      // we're passed &lt;originalAreaParam&gt;, the original area, and &lt;addedCountriesParam&gt;, a list of all the countries we're adding to it
      // this function adds the new countries to the area and then removes all of those new countries that it can remove
      // without increasing the number of borders of the total area (but doesn't remove any of the original countries)
      // and returns the resulting area as an ArrayList
      protected ArrayList&lt;Integer&gt; pruneAreaAddedCountries(ArrayList&lt;Integer&gt; originalAreaParam, ArrayList&lt;Integer&gt; addedCountriesParam) {
          // first, make a copy of both the lists that we got as parameters so we don't mess up the originals
          ArrayList&lt;Integer&gt; newArea = new ArrayList&lt;Integer&gt;(originalAreaParam);
          ArrayList&lt;Integer&gt; addedCountries = new ArrayList&lt;Integer&gt;(addedCountriesParam);

          // add the new countries to the original area to create &lt;newArea&gt;, which we'll then prune down
          newArea.addAll(addedCountries);

          // set some other variables we'll need in our loop
          boolean removed = true; // a flag that tells us if we removed any countries on a given iteration of the while loop

          // now we'll loop through &lt;addedCountries&gt; and remove as many countries as we can without increasing the number of borders of &lt;newArea&gt;
          // we'll loop around the whole list as long as we keep removing countries
          while (removed) { // keep looping as long as we removed a country last time
              removed = false; // set &lt;removed&gt; flag to false

              // loop through each country in &lt;addedCountries&gt;
              Iterator&lt;Integer&gt; addedCountriesIter = addedCountries.iterator();
              while (addedCountriesIter.hasNext()) {
                  int newCountry = addedCountriesIter.next(); // the country we're currently on in the loop

                  // now test the country we're on
                  // if the country itself is a border and if it touches 0 or 1 countries in the new area
                  // that aren't themselves borders, then we can remove it without increasing the total number of borders
                  if (isAreaBorder(newCountry, newArea)) { // if the country is itself a border
                      int[] neighbors = countries[newCountry].getAdjoiningCodeList(); // get neighbors
                      int numInteriorNeighbors = 0; // the number of interior neighbors (countries that &lt;country&gt; can attack that are in the area but are not borders of the area)
                      for (int neighbor : neighbors) { // loop through all neighbors
                          if (countries[newCountry].canGoto(neighbor) &amp;&amp; isInArray(neighbor,newArea) &amp;&amp; !isAreaBorder(neighbor, newArea)) { // if &lt;country&gt; can attack &lt;neighbor&gt; and neighbor is in &lt;newArea&gt; and &lt;neighbor&gt; is not a border
                              numInteriorNeighbors += 1;
                          }
                      }
                      if (numInteriorNeighbors &lt;= 1) { // if the country is touching no more than 1 interior country
                          // then we don't want to use it as a smart border, so
                          addedCountriesIter.remove(); // remove it from &lt;addedCountries&gt;
                          newArea.remove((Integer) newCountry); // and also from &lt;newArea&gt;
                          removed = true; // set &lt;removed&gt; flag to true so we will loop around the whole list again
                      }
                  }
              }
          }

          // return the pruned area
          return newArea;
      }

      // given a continent, get an array of continents that neighbor it and can attack it
      protected int[] getNeighboringContinents(int cont) {
          ArrayList&lt;Integer&gt; neighborConts = new ArrayList&lt;Integer&gt;();
          int[] neighbors = BoardHelper.getDefensibleBordersBeyond(cont, countries);
          for (int neighbor : neighbors) {
              int contCode = countries[neighbor].getContinent();
              if (!isInArray(contCode, neighborConts) &amp;&amp; contCode != cont) {
                  neighborConts.add(contCode);
              }
          }
          return convertListToIntArray(neighborConts);
      }

      // chat out all continent codes and names
      protected void chatContinentNames() {
          for (int i=0; i&lt;numConts; i++) {
              board.sendChat(i + &quot; - &quot; + board.getContinentName(i));
          }
      }

      // return the largest continent bonus of all continents on the board
      protected int getBiggestContinentBonus() {
          int biggestBonus = 0;
          for (int i=0; i&lt;numConts; i++) {
              int bonus = board.getContinentBonus(i);
              if (bonus &gt; biggestBonus) {
                  biggestBonus = bonus;
              }
          }
          return biggestBonus;
      }

      // checks if an integer is in an integer array
      protected boolean isInArray(int test, int[] array) {
          for (int element : array) {
              if (element == test) {
                  return true;
              }
          }
          return false;
      }
      protected boolean isInArray(int test, ArrayList&lt;Integer&gt; list) {
          int size = list.size();
          for (int i=0; i&lt;size; i++) {
              if (list.get(i) == test) {
                  return true;
              }
          }
          return false;
      }

      // get &quot;projected&quot; owner of the given country
      // returns &lt;ID&gt; if we actually own the country or if the country is in the battlPlan arraylist
      // because in that second case, that means we're planning on taking it over this turn
      protected int getProjectedCountryOwner(int country) {
          int currentOwner = countries[country].getOwner();
          if (isInBattlePlan(country)) {
              return ID;
          }
          return currentOwner;
      }

      // get &quot;projected&quot; armies on the given country
      // returns the actual armies on the country, unless we're planning on taking it over this turn
      // in which case it returns the number of armies we expect to leave on it after taking it over
      protected int getProjectedArmies(int country) {
          int armies = 0;
          if (isInBattlePlan(country)) {
              armies = checkBorderStrength(country) + 1;
          } else {
              armies = countries[country].getArmies();
          }
          return armies;
      }

      // checks if a given country is in the battlePlan arraylist
      protected boolean isInBattlePlan(int country) {
          for (int[] path : battlePlan) {
              for (int checkCountry : path) {
                  if (checkCountry == country) {
                      return true;
                  }
              }
          }
          return false;
      }

      // returns true if any country in the given area is contained within &lt;battlePlan&gt;
      protected boolean battlePlanHasCountryIn(int[] area) {
          for (int country : area) {
              if (isInBattlePlan(country)) {
                  return true;
              }
          }
          return false;
      }

      // return the total income of all enemies remaining in the game
      protected int getTotalEnemyIncome() {
          int numberOfPlayers = board.getNumberOfPlayers(); // number of players that started the game
          int totalEnemyIncome = 0;
          for (int player=0; player&lt;numberOfPlayers; player++) { // loop through all players
              if (BoardHelper.playerIsStillInTheGame(player, countries) &amp;&amp; isEnemy(player)) { // if the player is still in the game, and is an enemy
                  totalEnemyIncome += board.getPlayerIncome(player); // add its income to totalEnemyIncome
              }
          }
          return totalEnemyIncome;
      }

      // returns the income of the given player including their potential income from cars
      // (the value of the next card set * 1/3 the number of cards they have)
      protected int getPlayerIncomeAndCards(int player) {
          int income = board.getPlayerIncome(player); // the player's actual income
          income += Math.ceil((double) board.getPlayerCards(player) / 3.0d * (double) board.getNextCardSetValue());  // add the value of their cards, rounded up (each card is treated as 1/3 the value of the next card set)
          return income;
      }

      // converts an arraylist of integers into an array of integers
      protected int[] convertListToIntArray(ArrayList&lt;Integer&gt; list) {
          int size = list.size();
          int[] array = new int[size];
          for (int i=0; i&lt;size; i++) {
              array[i] = list.get(i);
          }
          return array;
      }
      // overloaded version to allow us to pass a set in place of a list
      protected int[] convertListToIntArray(Set&lt;Integer&gt; set) {
          ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(set);
          return convertListToIntArray(list);
      }

      // returns the key that contains the lowest value in a HashMap&lt;Integer, Integer&gt;
      protected Integer keyWithSmallestValue(HashMap&lt;Integer, Integer&gt; map) {
          if (map.isEmpty()) {
              return null;
          }

          ArrayList&lt;Integer&gt; keys = new ArrayList&lt;Integer&gt;(map.keySet());
          int smallestValKey = 0;
          int smallestValue = keys.get(0);
          for (int key : keys) {
              int value = map.get(key);
              if (value &lt; smallestValue) {
                  smallestValue = value;
                  smallestValKey = key;
              }
          }

          return smallestValKey;
      }
  }

        </code>
      </pre>
    </figure>
  </div>

  <div id="projectDisplay3" class="hiddenProject">
    <div><span>Title: </span><span>Ancient Greek Pronunciation</span></div>
    <div><span>Language: </span><span>Lua</span></div>
    <div><span>Purpose: </span><span>Converts an Ancient Greek word into IPA characters.</span></div>
    <div><span>Description: </span><span>Takes the spelling of an Ancient Greek word and derives its approximate pronunciation in five major eras of the language.
      For most consonants, this is a fairly straightforward replacement from a key-value array.  Vowels require looking at diacritics and surrounding context.
      The displayed code is from <a href="https://en.wiktionary.org/w/index.php?title=Module:grc-pronunciation&oldid=26564392"> the latest edit I made</a>, at which point I had authored the majority of the code.
      <a href="https://en.wiktionary.org/wiki/Module:grc-pronunciation">The current version</a> has undergone significant changes (likely improvements).
      It is used in the pronunciation section of a large number of Ancient Greek entries, such as <a href="https://en.wiktionary.org/wiki/%E1%BC%80%CF%84%CE%B5%CE%BB%CE%AE%CF%82#Ancient_Greek">ἀτελής</a>.</span></div>
    <figure>
      <pre>
<code>
  local export = {}

  local periods = {'cla', 'koi1', 'koi2', 'byz1', 'byz2'}
  local inlinePeriods = {'cla', 'koi2', 'byz2'}
  local IPAs = {}

  local periodLabels = {['cla']='[[w:Ancient Greek phonology|5th BC Attic]]',
  	['koi1'] = '[[w:Koine Greek phonology|1st BC Egyptian]]',
  	['koi2'] = '[[w:Koine Greek phonology|4th AD Koine]]',
  	['byz1'] = '[[w:Medieval Greek|10th AD Byzantine]]',
  	['byz2'] = '[[w:Medieval Greek|15th AD Constantinopolitan]]',
  	}

  --Combining diacritics are tricky.
  local d1 = '͜'   --Tie bar
  local d2 = '́'  --High pitch
  local d3 = '̀'  --Low pitch
  local d4 = '᷄'  --Mid/High pitch
  local d5 = '᷆'  --Mid/Low pitch
  local d6 = '᷇'  --High/Mid pitch
  local d7 = '̆'  --Short vowel length

  local l = {
  	[''] = {['end']=true},
  	[' '] = {['p'] = {['cla'] = ' '}},
  	['&beta;'] = {['type'] = 'consonant', ['labial'] = true, ['stop'] = true, ['voiced']=true, ['clusters']={['&delta;']=true, ['&lambda;']=true, ['&rho;']=true},
  		['p'] = {['cla']='b', ['koi1']='b', ['koi2']='&beta;', ['byz1']='v', ['byz2']={{'1=&beta;', ''}, {'-1=&mu;', 'b'}, 'v'}}},
  	['&gamma;'] = {['type'] = 'consonant', ['dorsal'] = true, ['stop'] = true, ['voiced']=true, ['clusters']={['&lambda;']=true, ['&nu;']=true, ['&rho;']=true},
  		['p'] = {['cla']={{'1.dorsal', 'ŋ'}, 'ɡ'}, ['koi1']={{'1.dorsal', 'ŋ'}, 'ɡ'},
  			['koi2']={{'1.dorsal', 'ŋ'}, 'ɣ'},
  			['byz1']={{'1.dorsal', {{'1-preFront', 'ɲ'}, 'ŋ'}}, {'0-preFront', {{'-1=&gamma;', 'ɟ'}, 'ʝ'}}, 'ɣ'},
  			['byz2']={{'1.dorsal', {{'1-preFront', 'ɲ'}, 'ŋ'}}, {'0-preFront', {{'-1=&gamma;', 'ɟ'}, 'ʝ'}}, 'ɣ'}}},
  	['&delta;'] = {['type'] = 'consonant', ['place']='coronal', ['stop']=true, ['voiced']=true, ['clusters']={['&rho;']=true},
  		['p'] = {['cla']='d', ['koi1']='d', ['koi2']='&eth;', ['byz1']='&eth;', ['byz2']={{'1=&delta;', ''}, {'-1=&nu;', 'd'}, '&eth;'}}},
  	['&zeta;'] = {['type'] = 'consonant', ['place']='coronal', ['fricative']=true, ['voiced']=true, ['clusters']={},
  		['p'] = {['cla']='zd', ['koi1']='z', ['koi2']='z', ['byz1']='z', ['byz2']='z'}},
  	['&theta;'] = {['type'] = 'consonant', ['place']='coronal', ['stop']=true, ['unvoiced']=true, ['aspirate']=true, ['clusters']={['&rho;']=true},
  		['p'] = {['cla']='tʰ', ['koi1']='tʰ', ['koi2']='&theta;', ['byz1']='&theta;', ['byz2']={{'1=&theta;', ''}, '&theta;'}}},
  	['&kappa;'] = {['type'] = 'consonant', ['place']='dorsal', ['stop']=true, ['unvoiced']=true, ['clusters']={['&lambda;']=true, ['&nu;']=true, ['&tau;']=true, ['&rho;']=true},
  		['p'] = {['cla']={{'1.voiced+1.stop', 'ɡ'}, 'k'},
  			['koi1']={{'1.voiced+1.stop', 'ɡ'}, 'k'},
  			['koi2']={{'1.voiced+1.stop', 'ɡ'}, 'k'},
  			['byz1']={{'1=&kappa;', ''}, {'1.voiced+1.stop', 'ɡ'}, {'0-preFront', 'c'}, 'k'},
  			['byz2']={{'1=&kappa;', ''}, {'1.voiced+1.stop', 'ɡ'}, {'0-preFront', 'c'}, 'k'}}},
  	['&lambda;'] = {['type'] = 'consonant', ['place']='coronal', ['approximant']=true, ['voiced']=true, ['clusters']={},
  		['p'] = {['cla']='l', ['koi1']='l', ['koi2']='l', ['byz1']='l', ['byz2']={{'1=&lambda;', ''}, 'l'}}},
  	['&mu;'] = {['type'] = 'consonant', ['place']='labial', ['nasal']=true, ['voiced']=true, ['clusters']={['&nu;']=true},
  		['p'] = {['cla']='m', ['koi1']='m', ['koi2']='m', ['byz1']='m', ['byz2']={{'1=&mu;/1=&beta;', ''}, 'm'}}},
  	['&nu;'] = {['type'] = 'consonant', ['place']='coronal', ['nasal']=true, ['voiced']=true, ['clusters']={},
  		['p'] = {['cla']='n', ['koi1']='n', ['koi2']='n', ['byz1']='n', ['byz2']={{'1=&nu;/1=&delta;', ''}, 'n'}}},
  	['&xi;'] = {['type'] = 'consonant', ['place']='dorsal', ['stop']=true, ['unvoiced']=true, ['sibilate']=true, ['clusters']={},
  		['p'] = {['cla']='kʰs', ['koi1']='kʰs', ['koi2']='xs', ['byz1']='ks', ['byz2']='ks'}},
  	['&pi;'] = {['type'] = 'consonant', ['place']='labial', ['stop']=true, ['unvoiced']=true, ['clusters']={['&lambda;']=true, ['&nu;']=true, ['&rho;']=true, ['&tau;']=true},
  		['p'] = {['cla']='p', ['koi1']='p', ['koi2']='p', ['byz1']='p', ['byz2']={{'1=&pi;', ''}, 'p'}}},
  	['&rho;'] = {['type'] = 'consonant', ['place']='coronal', ['trill']=true, ['voiced']=true, ['clusters']={},
  		['p'] = {['cla']={{'1=&rho;/1=ῥ/-1=&rho;', 'r̥'}, 'r'}, ['koi1']={{'1=&rho;/1=ῥ/-1=&rho;', 'r̥'}, 'r'}, ['koi2']='r', ['byz1']='r', ['byz2']={{'1=&rho;', ''}, 'r'}}},
  	['ῥ'] = {['type'] = 'consonant', ['place']='coronal', ['trill']=true, ['voiced']=false, ['clusters']={},
  		['p'] = {['cla']='r̥', ['koi1']='r̥', ['koi2']='r', ['byz1']='r', ['byz2']={{'1=&rho;', ''}, 'r'}}},
  	['&sigma;'] = {['type'] = 'consonant', ['place']='coronal', ['fricative']=true, ['unvoiced']=true, ['clusters']={['&beta;']=true, ['&theta;']=true, ['&kappa;']=true, ['&mu;']=true, ['&pi;']=true, ['&tau;']=true, ['&phi;']=true, ['&chi;']=true, },
  		['p'] = {['cla']='s', ['koi1']='s', ['koi2']='s', ['byz1']='s', ['byz2']={{'1=&sigma;', ''}, 's'}}},
  	['&tau;'] = {['type'] = 'consonant', ['place']='coronal', ['stop']=true, ['unvoiced']=true, ['clusters']={['&lambda;']=true, ['&mu;']=true, ['&rho;']=true},
  		['p'] = {['cla']='t', ['koi1']='t', ['koi2']='t', ['byz1']='t', ['byz2']={{'1=&tau;', ''}, 't'}}},
  	['&phi;'] = {['type'] = 'consonant', ['place']='labial', ['stop']=true, ['unvoiced']=true, ['clusters']={['&theta;']=true, ['&lambda;']=true, ['&rho;']=true},
  		['p'] = {['cla']='pʰ', ['koi1']='pʰ', ['koi2']='ɸ', ['byz1']='f', ['byz2']={{'1=&phi;', ''}, 'f'}}},
  	['&chi;'] = {['type'] = 'consonant', ['dorsal']=true, ['stop']=true, ['unvoiced']=true, ['aspirate']=true, ['clusters']={['&theta;']=true, ['&lambda;']=true, ['&rho;']=true},
  		['p'] = {['cla']='kʰ', ['koi1']='kʰ', ['koi2']='x',
  			['byz1']={{'1=&chi;', ''}, {'0-preFront', '&ccedil;'}, 'x'},
  			['byz2']={{'1=&chi;', ''}, {'0-preFront', '&ccedil;'}, 'x'}}},
  	['&psi;'] = {['type'] = 'consonant', ['place']='labial', ['stop']=true, ['unvoiced']=true, ['sibilate']=true, ['clusters']={},
  		['p'] = {['cla']='pʰs', ['koi1']='pʰs', ['koi2']='ɸs', ['byz1']='ps', ['byz2']='ps'}},
  	['&alpha;'] = {['type'] = 'vowel', ['length']='either',
  		['p'] = {['cla']='a', ['koi1']='a', ['koi2']='a', ['byz1']='a', ['byz2']='a'}},
  	['&epsilon;'] = {['type'] = 'vowel', ['length']='short',
  		['p'] = {['cla']='e', ['koi1']='ɛ', ['koi2']='e', ['byz1']='e', ['byz2']='e'}},
  	['&eta;'] = {['type'] = 'vowel', ['length']='long',
  		['p'] = {['cla']='ɛ', ['koi1']='e', ['koi2']='i', ['byz1']='i', ['byz2']='i'}},
  	['&iota;'] = {['type'] = 'vowel', ['length']='either',
  		['p'] = {['cla']='i', ['koi1']='i', ['koi2']='i', ['byz1']='i', ['byz2']='i'}},
  	['&omicron;'] = {['type'] = 'vowel', ['length']='short',
  		['p'] = {['cla']='o', ['koi1']='o', ['koi2']='o', ['byz1']='o', ['byz2']='o'}},
  	['&upsilon;'] = {['type'] = 'vowel', ['length']='either',
  		['p'] = {['cla']='y', ['koi1']='y', ['koi2']='y', ['byz1']='y', ['byz2']='i'}},
  	['&omega;'] = {['type'] = 'vowel', ['length']='long',
  		['p'] = {['cla']='ɔ', ['koi1']='o', ['koi2']='o', ['byz1']='o', ['byz2']='o'}},
  	['ϊ'] = {['type'] = 'vowel', ['naked']='&iota;', ['diar']=true},
  	['ϋ'] = {['type'] = 'vowel', ['naked']='&upsilon;', ['diar']=true},
  	['ἀ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['breath']='smooth'},
  	['ἐ'] = {['type'] = 'vowel', ['naked']='&epsilon;', ['breath']='smooth'},
  	['ἠ'] = {['type'] = 'vowel', ['naked']='&eta;', ['breath']='smooth'},
  	['ἰ'] = {['type'] = 'vowel', ['naked']='&iota;', ['breath']='smooth'},
  	['ὀ'] = {['type'] = 'vowel', ['naked']='&omicron;', ['breath']='smooth'},
  	['ὐ'] = {['type'] = 'vowel', ['naked']='&upsilon;', ['breath']='smooth'},
  	['ὠ'] = {['type'] = 'vowel', ['naked']='&omega;', ['breath']='smooth'},
  	['ὰ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['accent']='grave'},
  	['ᾀ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['breath']='smooth', ['subi']=true},
  	['ᾐ'] = {['type'] = 'vowel', ['naked']='&eta;', ['breath']='smooth', ['subi']=true},
  	['ᾠ'] = {['type'] = 'vowel', ['naked']='&omega;', ['breath']='smooth', ['subi']=true},
  	['ᾰ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['length']='short'},
  	['ῐ'] = {['type'] = 'vowel', ['naked']='&iota;', ['length']='short'},
  	['ῠ'] = {['type'] = 'vowel', ['naked']='&upsilon;', ['length']='short'},
  	['ἁ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['breath']='rough'},
  	['ἑ'] = {['type'] = 'vowel', ['naked']='&epsilon;', ['breath']='rough'},
  	['ἡ'] = {['type'] = 'vowel', ['naked']='&eta;', ['breath']='rough'},
  	['ἱ'] = {['type'] = 'vowel', ['naked']='&iota;', ['breath']='rough'},
  	['ὁ'] = {['type'] = 'vowel', ['naked']='&omicron;', ['breath']='rough'},
  	['ὑ'] = {['type'] = 'vowel', ['naked']='&upsilon;', ['breath']='rough'},
  	['ὡ'] = {['type'] = 'vowel', ['naked']='&omega;', ['breath']='rough'},
  	['ά'] = {['type'] = 'vowel', ['naked']='&alpha;', ['accent']='acute'},
  	['ᾁ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['breath']='rough', ['subi']=true},
  	['ᾑ'] = {['type'] = 'vowel', ['naked']='&eta;', ['breath']='rough', ['subi']=true},
  	['ᾡ'] = {['type'] = 'vowel', ['naked']='&omega;', ['breath']='rough', ['subi']=true},
  	['ᾱ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['length']='long'},
  	['ῑ'] = {['type'] = 'vowel', ['naked']='&iota;', ['length']='long'},
  	['ῡ'] = {['type'] = 'vowel', ['naked']='&upsilon;', ['length']='long'},
  	['ἂ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['breath']='smooth', ['accent']='grave'},
  	['ἒ'] = {['type'] = 'vowel', ['naked']='&epsilon;', ['breath']='smooth', ['accent']='grave'},
  	['ἢ'] = {['type'] = 'vowel', ['naked']='&eta;', ['breath']='smooth', ['accent']='grave'},
  	['ἲ'] = {['type'] = 'vowel', ['naked']='&iota;', ['breath']='smooth', ['accent']='grave'},
  	['ὂ'] = {['type'] = 'vowel', ['naked']='&omicron;', ['breath']='smooth', ['accent']='grave'},
  	['ὒ'] = {['type'] = 'vowel', ['naked']='&upsilon;', ['breath']='smooth', ['accent']='grave'},
  	['ὢ'] = {['type'] = 'vowel', ['naked']='&omega;', ['breath']='smooth', ['accent']='grave'},
  	['ὲ'] = {['type'] = 'vowel', ['naked']='&epsilon;', ['accent']='grave'},
  	['ᾂ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['breath']='smooth', ['accent']='grave', ['subi']=true},
  	['ᾒ'] = {['type'] = 'vowel', ['naked']='&eta;', ['breath']='smooth', ['accent']='grave', ['subi']=true},
  	['ᾢ'] = {['type'] = 'vowel', ['naked']='&omega;', ['breath']='smooth', ['accent']='grave', ['subi']=true},
  	['ᾲ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['accent']='grave', ['subi']=true},
  	['ῂ'] = {['type'] = 'vowel', ['naked']='&eta;', ['accent']='grave', ['subi']=true},
  	['ῒ'] = {['type'] = 'vowel', ['naked']='&iota;', ['accent']='grave', ['diar']=true},
  	['ῢ'] = {['type'] = 'vowel', ['naked']='&upsilon;', ['accent']='grave', ['diar']=true},
  	['ῲ'] = {['type'] = 'vowel', ['naked']='&omega;', ['accent']='grave', ['subi']=true},
  	['ἃ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['accent']='grave', ['breath']='rough'},
  	['ἓ'] = {['type'] = 'vowel', ['naked']='&epsilon;', ['accent']='grave', ['breath']='rough'},
  	['ἣ'] = {['type'] = 'vowel', ['naked']='&eta;', ['accent']='grave', ['breath']='rough'},
  	['ἳ'] = {['type'] = 'vowel', ['naked']='&iota;', ['accent']='grave', ['breath']='rough'},
  	['ὃ'] = {['type'] = 'vowel', ['naked']='&omicron;', ['accent']='grave', ['breath']='rough'},
  	['ὓ'] = {['type'] = 'vowel', ['naked']='&upsilon;', ['accent']='grave', ['breath']='rough'},
  	['ὣ'] = {['type'] = 'vowel', ['naked']='&omega;', ['accent']='grave', ['breath']='rough'},
  	['έ'] = {['type'] = 'vowel', ['naked']='&epsilon;', ['accent']='acute'},
  	['ᾃ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['accent']='grave', ['breath']='rough', ['subi']=true},
  	['ᾓ'] = {['type'] = 'vowel', ['naked']='&eta;', ['accent']='grave', ['breath']='rough', ['subi']=true},
  	['ᾣ'] = {['type'] = 'vowel', ['naked']='&omega;', ['accent']='grave', ['breath']='rough', ['subi']=true},
  	['ᾳ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['subi']=true},
  	['ῃ'] = {['type'] = 'vowel', ['naked']='&eta;', ['subi']=true},
  	['ΐ'] = {['type'] = 'vowel', ['naked']='&iota;', ['accent']='acute', ['diar']=true},
  	['ΰ'] = {['type'] = 'vowel', ['naked']='&upsilon;', ['accent']='acute', ['diar']=true},
  	['ῳ'] = {['type'] = 'vowel', ['naked']='&omega;', ['subi']=true},
  	['ἄ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['accent']='acute', ['breath']='smooth'},
  	['ἔ'] = {['type'] = 'vowel', ['naked']='&epsilon;', ['accent']='acute', ['breath']='smooth'},
  	['ἤ'] = {['type'] = 'vowel', ['naked']='&eta;', ['accent']='acute', ['breath']='smooth'},
  	['ἴ'] = {['type'] = 'vowel', ['naked']='&iota;', ['accent']='acute', ['breath']='smooth'},
  	['ὄ'] = {['type'] = 'vowel', ['naked']='&omicron;', ['accent']='acute', ['breath']='smooth'},
  	['ὔ'] = {['type'] = 'vowel', ['naked']='&upsilon;', ['accent']='acute', ['breath']='smooth'},
  	['ὤ'] = {['type'] = 'vowel', ['naked']='&omega;', ['accent']='acute', ['breath']='smooth'},
  	['ὴ'] = {['type'] = 'vowel', ['naked']='&eta;', ['accent']='grave'},
  	['ᾄ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['accent']='acute', ['breath']='smooth', ['subi']=true},
  	['ᾔ'] = {['type'] = 'vowel', ['naked']='&eta;', ['accent']='acute', ['breath']='smooth', ['subi']=true},
  	['ᾤ'] = {['type'] = 'vowel', ['naked']='&omega;', ['accent']='acute', ['breath']='smooth', ['subi']=true},
  	['ᾴ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['accent']='acute', ['subi']=true},
  	['ῄ'] = {['type'] = 'vowel', ['naked']='&eta;', ['accent']='acute', ['subi']=true},
  	['ῴ'] = {['type'] = 'vowel', ['naked']='&omega;', ['accent']='acute', ['subi']=true},
  	['ἅ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['accent']='acute', ['breath']='rough'},
  	['ἕ'] = {['type'] = 'vowel', ['naked']='&epsilon;', ['accent']='acute', ['breath']='rough'},
  	['ἥ'] = {['type'] = 'vowel', ['naked']='&eta;', ['accent']='acute', ['breath']='rough'},
  	['ἵ'] = {['type'] = 'vowel', ['naked']='&iota;', ['accent']='acute', ['breath']='rough'},
  	['ὅ'] = {['type'] = 'vowel', ['naked']='&omicron;', ['accent']='acute', ['breath']='rough'},
  	['ὕ'] = {['type'] = 'vowel', ['naked']='&upsilon;', ['accent']='acute', ['breath']='rough'},
  	['ὥ'] = {['type'] = 'vowel', ['naked']='&omega;', ['accent']='acute', ['breath']='rough'},
  	['ή'] = {['type'] = 'vowel', ['naked']='&eta;', ['accent']='acute'},
  	['ᾅ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['accent']='acute', ['breath']='rough', ['subi']=true},
  	['ᾕ'] = {['type'] = 'vowel', ['naked']='&eta;', ['accent']='acute', ['breath']='rough', ['subi']=true},
  	['ᾥ'] = {['type'] = 'vowel', ['naked']='&omega;', ['accent']='acute', ['breath']='rough', ['subi']=true},
  	['ἆ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['accent']='circum', ['breath']='smooth'},
  	['ἦ'] = {['type'] = 'vowel', ['naked']='&eta;', ['accent']='circum', ['breath']='smooth'},
  	['ἶ'] = {['type'] = 'vowel', ['naked']='&iota;', ['accent']='circum', ['breath']='smooth'},
  	['ὖ'] = {['type'] = 'vowel', ['naked']='&upsilon;', ['accent']='circum', ['breath']='smooth'},
  	['ὦ'] = {['type'] = 'vowel', ['naked']='&omega;', ['accent']='circum', ['breath']='smooth'},
  	['ὶ'] = {['type'] = 'vowel', ['naked']='&iota;', ['accent']='grave'},
  	['ᾆ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['accent']='circum', ['breath']='smooth', ['subi']=true},
  	['ᾖ'] = {['type'] = 'vowel', ['naked']='&eta;', ['accent']='circum', ['breath']='smooth', ['subi']=true},
  	['ᾦ'] = {['type'] = 'vowel', ['naked']='&omega;', ['accent']='circum', ['breath']='smooth', ['subi']=true},
  	['ᾶ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['accent']='circum'},
  	['ῆ'] = {['type'] = 'vowel', ['naked']='&eta;', ['accent']='circum'},
  	['ῖ'] = {['type'] = 'vowel', ['naked']='&iota;', ['accent']='circum'},
  	['ῦ'] = {['type'] = 'vowel', ['naked']='&upsilon;', ['accent']='circum'},
  	['ῶ'] = {['type'] = 'vowel', ['naked']='&omega;', ['accent']='circum'},
  	['ἇ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['accent']='circum', ['breath']='rough'},
  	['ἧ'] = {['type'] = 'vowel', ['naked']='&eta;', ['accent']='circum', ['breath']='rough'},
  	['ἷ'] = {['type'] = 'vowel', ['naked']='&iota;', ['accent']='circum', ['breath']='rough'},
  	['ὗ'] = {['type'] = 'vowel', ['naked']='&upsilon;', ['accent']='circum', ['breath']='rough'},
  	['ὧ'] = {['type'] = 'vowel', ['naked']='&omega;', ['accent']='circum', ['breath']='rough'},
  	['ί'] = {['type'] = 'vowel', ['naked']='&iota;', ['accent']='acute'},
  	['ᾇ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['accent']='circum', ['breath']='rough', ['subi']=true},
  	['ᾗ'] = {['type'] = 'vowel', ['naked']='&eta;', ['accent']='circum', ['breath']='rough', ['subi']=true},
  	['ᾧ'] = {['type'] = 'vowel', ['naked']='&omega;', ['accent']='circum', ['breath']='rough', ['subi']=true},
  	['ᾷ'] = {['type'] = 'vowel', ['naked']='&alpha;', ['accent']='circum', ['subi']=true},
  	['ῇ'] = {['type'] = 'vowel', ['naked']='&eta;', ['accent']='circum', ['subi']=true},
  	['ῗ'] = {['type'] = 'vowel', ['naked']='&iota;', ['accent']='circum', ['diar']=true},
  	['ῧ'] = {['type'] = 'vowel', ['naked']='&upsilon;', ['accent']='circum', ['diar']=true},
  	['ῷ'] = {['type'] = 'vowel', ['naked']='&omega;', ['accent']='circum', ['subi']=true},
  	['ὸ'] = {['type'] = 'vowel', ['naked']='&omicron;', ['accent']='grave'},
  	['ό'] = {['type'] = 'vowel', ['naked']='&omicron;', ['accent']='acute'},
  	['ὺ'] = {['type'] = 'vowel', ['naked']='&upsilon;', ['accent']='grave'},
  	['ύ'] = {['type'] = 'vowel', ['naked']='&upsilon;', ['accent']='acute'},
  	['ὼ'] = {['type'] = 'vowel', ['naked']='&omega;', ['accent']='grave'},
  	['ώ'] = {['type'] = 'vowel', ['naked']='&omega;', ['accent']='acute'},
  	['&alpha;&iota;'] = {['p'] = {['cla'] = {{'1.end', 'a'..d7..d1..'ɪ'..d7}, 'a'..d1..'ɪ'}, ['koi1']='ɛ', ['koi2']='ɛ', ['byz1']='e', ['byz2']='e'}},
  	['&epsilon;&iota;'] = {['p'] = {['cla'] = 'e', ['koi1']='i', ['koi2']='i', ['byz1']='i', ['byz2']='i'}},
  	['&omicron;&iota;'] = {['p'] = {['cla'] = {{'1.end', 'o'..d7..d1..'ɪ'..d7}, 'o'..d1..'ɪ'}, ['koi1']='y', ['koi2']='y', ['byz1']='y', ['byz2']='i'}},
  	['&upsilon;&iota;'] = {['p'] = {['cla'] = 'y', ['koi1']='y', ['koi2']='y', ['byz1']='y', ['byz2']='i'}},
  	['&alpha;&upsilon;'] = {['p'] = {['cla'] = 'a'..d1..'ʊ', ['koi1']={{'1.unvoiced', 'aʍ'}, 'aw'},
  		['koi2']={{'1.unvoiced', 'aɸ'}, 'a&beta;'}, ['byz1']={{'1.unvoiced', 'af'}, 'av'},
  		['byz2']={{'1.unvoiced', 'af'}, 'av'}}},
  	['&epsilon;&upsilon;'] = {['p'] = {['cla'] = 'e'..d1..'ʊ', ['koi1']={{'1.unvoiced', 'eʍ'}, 'ew'},
  		['koi2']={{'1.unvoiced', 'eɸ'}, 'e&beta;'}, ['byz1']={{'1.unvoiced', 'ef'}, 'ev'},
  		['byz2']={{'1.unvoiced', 'ef'}, 'ev'}}},
  	['&omicron;&upsilon;'] = {['p'] = {['cla'] = 'o', ['koi1']='u', ['koi2']='u', ['byz1']='u', ['byz2']='u'}},
  	}

  local uStart = {['&alpha;'] = true, ['&epsilon;'] = true, ['&omicron;'] = true}
  local iStart = {['&alpha;'] = true, ['&epsilon;'] = true, ['&omicron;'] = true, ['&upsilon;'] = true}

  local iCons = {['b']=true, ['ɡ']=true, ['ŋ']=true, ['d']=true, ['z']=true,
  	['k']=true, ['l']=true, ['m']=true, ['n']=true, ['p']=true, ['r']=true,
  	['s']=true, ['t']=true, ['&beta;']=true, ['&eth;']=true, ['ɣ']=true, ['ɸ']=true,
  	['&theta;']=true, ['x']=true, ['f']=true, ['v']=true, ['ɟ']=true, ['ʝ']=true,
  	['c']=true, ['&ccedil;']=true}

  local iVows = {['a']=true, ['e']=true, ['i']=true, ['o']=true, ['u']=true,
  	['y']=true, ['ʊ']=true, ['ɪ']=true, ['ɛ']=true, ['ɔ']=true}

  local iDias = {[d2]=true, [d3]=true, [d4]=true, [d5]=true, [d6]=true, [d7]=true,
  	['ʰ']=true, ['ː']=true, ['̥']=true}

  local iLiqs = {['r']=true, ['l']=true, ['n']=true}

  local iStops = {['b']=true, ['ɡ']=true, ['d']=true, ['k']=true, ['p']=true,
  	['t']=true, ['&beta;']=true, ['&eth;']=true, ['ɣ']=true, ['ɸ']=true, ['&theta;']=true,
  	['x']=true, ['f']=true}


  function export.create(frame)
  	local args = frame:getParent().args
  	local title = args['w'] or mw.title.getCurrentTitle().text
  	title = mw.ustring.lower(title)
  	title = mw.ustring.gsub(title, '&sigmaf;', '&sigma;')
  	title = mw.ustring.gsub(title, 'ῤ', '&rho;')
  	for i=1, #periods do
  		IPAs[periods[i]] = {['notes']={}}
  	end
  	local length = mw.ustring.len(title)
  	local x = 1
  	local letter = ''
  	local nextLetter = ''
  	local cla = {}
  	local alert = false
  	local naked = ''
  	local accent = ''
  	local diphthong = false
  	--local clusters = {}
  	--local cluster = ''
  	local function preFront(which)
  		local fronts = {['&iota;']=true, ['&eta;']=true, ['&epsilon;']=true}
  		local nLet = mw.ustring.sub(title, x+1+which, x+1+which)
  		local nnLet = mw.ustring.sub(title, x+2+which, x+2+which)
  		if fronts[((l[nLet].naked) or nLet)] then
  			return true
  		elseif (nLet == 'a' or nLet == '&omicron;') and ((l[nnLet].naked or nnLet) == '&iota;') then
  			return true
  		else
  			return false
  		end
  	end

  	local function decode(condition)
  		if mw.ustring.find(condition, '[+/]') then  --&quot;If&quot; and &quot;and&quot; statements.
  			--Note that we're finding the last operator first,
  			--which means that the first will get ultimately get decided first.
  			--It's a recursive function.
  			local sep = mw.ustring.find(condition, &quot;[/+][^/+]*$&quot;)
  			local chunk1 = mw.ustring.sub(condition, 1, sep - 1)
  			local chunk2 = mw.ustring.sub(condition, sep + 1)
  			if mw.ustring.sub(condition, sep, sep) == '/' then
  				return decode(chunk1) or decode(chunk2)
  			elseif mw.ustring.sub(condition, sep, sep) == '+' then
  				return decode(chunk1) and decode(chunk2)
  			end
  		elseif mw.ustring.find(condition, '=') then
  			local sep = mw.ustring.find(condition, '=')
  			local chunk1 = mw.ustring.sub(condition, 1, sep - 1)
  			local chunk2 = mw.ustring.sub(condition, sep + 1)
  			local checkLetter
  			if tonumber(x+chunk1) &lt; 1 then
  				checkLetter = ''
  			else
  				checkLetter = mw.ustring.sub(title, x+chunk1, x+chunk1)
  			end
  			return checkLetter == chunk2
  		elseif mw.ustring.find(condition, '%.') then
  			local sep = mw.ustring.find(condition, '%.')
  			local chunk1 = mw.ustring.sub(condition, 1, sep - 1)
  			local chunk2 = mw.ustring.sub(condition, sep + 1)
  			local checkLetter = mw.ustring.sub(title, x+chunk1, x+chunk1)
  			return l[checkLetter][chunk2]
  		elseif mw.ustring.find(condition, '%-') then
  			local sep = mw.ustring.find(condition, '%-')
  			local chunk1 = mw.ustring.sub(condition, 1, sep - 1)
  			local chunk2 = mw.ustring.sub(condition, sep + 1)
  			if chunk2 == 'preFront' then
  				return preFront(chunk1)
  			end
  		end

  	end
  	local function check(p, period)
  		if type(p) == 'string' then
  			return p
  		elseif type(p) == 'table' then   --This table is sequential, with a variable number of entries.
  			for i = 1, #p do
  				possP = p[i]
  				if type(possP) == 'string' then
  					return possP
  				elseif type(possP) == 'table' then    --This table is paired, with two values: a condition and a result.
  					rawCondition = possP[1]
  					rawResult = possP[2]
  					local condition = decode(rawCondition)
  					if condition then
  						if type(rawResult) == 'string' then
  							return rawResult
  						else
  							return check(rawResult, period)
  						end
  					end
  				end
  			end
  		end
  	end
  	while x &lt;= length do
  		letter = mw.ustring.sub(title, x, x)
  		nextLetter = mw.ustring.sub(title, x+1, x+1)
  		if not l[letter] then

  		elseif l[letter].type == 'consonant' then
  			for i = 1, #periods do
  				period = periods[i]
  				currentP = l[letter].p[period]
  				result = check(currentP, period)
  				table.insert(IPAs[period], result)
  			end

  		elseif l[letter].type == 'vowel' then

  			--Start with a diphthong check
  			local diphthong = false
  			local vCurrent, vForm, vLength;
  			if iStart[letter] and (l[nextLetter] and l[nextLetter].type == 'vowel' and (nextLetter == '&iota;' or (l[nextLetter].naked and l[nextLetter].naked == '&iota;' and not l[nextLetter].diar))) then
  				diphthong = letter..'&iota;'
  			elseif uStart[letter] and (l[nextLetter] and l[nextLetter].type == 'vowel' and (nextLetter == '&upsilon;' or (l[nextLetter].naked and l[nextLetter].naked == '&upsilon;' and not l[nextLetter].diar))) then
  				diphthong = letter..'&upsilon;'
  			end

  			if diphthong then
  				vCurrent = nextLetter
  				vForm = diphthong
  				vLength = 'long'
  				x = x + 1
  				nextLetter = mw.ustring.sub(title, x+1, x+1)
  			else
  				vCurrent = letter
  				vForm = l[letter].naked or letter
  				vLength = l[vCurrent].length or l[vForm].length
  			end
  			for i = 1, #periods do
  				period = periods[i]
  				if period == 'cla' then
  					if l[vCurrent].breath == 'rough' then
  						table.insert(IPAs['cla'], 'h')
  					end
  				elseif period == 'koi1' then
  					if l[vCurrent].breath == 'rough' then
  						table.insert(IPAs['koi1'], '(h)')
  					end
  				end
  				if period ~= 'cla' then
  					--All other periods have a stress accent, instead of Classical's tonal accent.
  					--The stress diacritic is initially placed immediately preceding the vowel,
  					--and is moved to the front of the syllable during syllabification.
  					if l[vCurrent].accent then
  						table.insert(IPAs[period], 'ˈ')
  					end
  					local vIP = check(l[vForm].p[period], period)
  					table.insert(IPAs[period], vIP)

  				else
  					--Classical vowels are hard.
  					if vLength == 'either' then
  						if l[vCurrent].accent == 'circum' then
  							vLength = 'long'
  						elseif l[vCurrent].subi then
  							vLength = 'long'
  						elseif nextLetter == '̄' or nextLetter == '&macr;' then
  							vLength = 'long'
  						elseif nextLetter == '̆' or nextLetter == '˘' then
  							vLength = 'short'
  						else
  							table.insert(IPAs.cla.notes, 'ambiguous vowel '..vCurrent..' at '..x)
  						end
  					end

  					local vIP = check(l[vForm].p.cla, cla)  --vIP stands for initial pronunciation

  					--There has to be a prettier way to do this, but I just can't think of it.
  					if mw.ustring.len(vIP) &gt; 1 then  --i.e. if it's a phonetic dipthong
  						if l[vCurrent].accent == 'acute' then
  							vFP = vIP..d2
  						elseif l[vCurrent].accent == 'grave' then
  							vFP = vIP..d3
  						elseif l[vCurrent].accent == 'circum' then
  							vFP = mw.ustring.sub(vIP, 1, 1)..d2..mw.ustring.sub(vIP, 2)
  						else
  							vFP = vIP
  						end
  					elseif l[vCurrent].subi then
  						if l[vCurrent].accent == 'acute' then
  							vFP = vIP..d1..'ːɪ'..d2
  						elseif l[vCurrent].accent == 'grave' then
  							vFP = vIP..d1..'ːɪ'..d3
  						elseif l[vCurrent].accent == 'circum' then
  							vFP = vIP..d2..d1..'ːɪ'
  						else
  							vFP = vIP..d1..'ːɪ'
  						end
  					elseif vLength == 'long' then
  						if l[vCurrent].accent == 'acute' then
  							vFP = vIP..d4..'ː'
  						elseif l[vCurrent].accent == 'grave' then
  							vFP = vIP..d5..'ː'
  						elseif l[vCurrent].accent == 'circum' then
  							vFP = vIP..d6..'ː'
  						else
  							vFP = vIP..'ː'
  						end
  					else
  						if l[vCurrent].accent == 'acute' then
  							vFP = vIP..d2
  						elseif l[vCurrent].accent == 'grave' then
  							vFP = vIP..d3
  						else
  							vFP = vIP
  						end
  					end
  					table.insert(IPAs['cla'], vFP)

  				end
  			end
  		else
  			alert = true
  		end
  		x = x + 1
  	end

  	--Concatenate the IPAs
  	for i=1, #periods do
  		IPAs[periods[i]] = {['IPA']=table.concat(IPAs[periods[i]], ''), ['notes']=IPAs[periods[i]]['notes']}
  	end

  	--Syllabify
  	for i=1, #periods do
  		local period = periods[i]
  		local word = IPAs[period].IPA
  		local syllables = {}
  		local cVowel, nVowel, sBreak, stress, wordEnd, searching
  		--word = ''
  		while word ~= '' do
  			cVowel, nVowel, sBreak, stress = false, false, false, false

  			--First thing is to find the first vowel.
  			searching = 1
  			cVowelFound = false
  			while not cVowel do
  				letter = mw.ustring.sub(word, searching, searching)
  				if cVowelFound then
  					if iVows[letter] or iCons[letter] or letter == '' or letter == 'ˈ' then
  						cVowel = searching - 1
  					elseif iDias[letter] then
  						searching = searching + 1
  					elseif letter == d1 then
  						cVowelFound = false
  						searching = searching + 1
  					else
  						searching = searching + 1
  					end
  				else
  					if iVows[letter] then
  						cVowelFound = true
  					elseif letter == 'ˈ' then
  						stress = true
  					elseif letter == '' then  --This shouldn't happen.
  						cVowel = true
  						wordEnd = true
  					end
  					searching = searching + 1
  				end
  			end

  			--Next we try and find the next vowel or the end.
  			searching = cVowel + 1
  			while (not nVowel) and (not wordEnd) do
  				letter = mw.ustring.sub(word, searching, searching)
  				if iVows[letter] or letter == 'ˈ' then
  					nVowel = searching
  				elseif letter == '' then
  					wordEnd = true
  				else
  					searching = searching + 1
  				end
  			end

  			--Finally we find the syllable break point.
  			if wordEnd then
  				sBreak = mw.ustring.len(word)
  			elseif iLiqs[mw.ustring.sub(word, nVowel-1, nVowel-1)] then
  				if iStops[mw.ustring.sub(word, nVowel-2, nVowel-2)] then
  					sBreak = nVowel - 3
  				elseif mw.ustring.sub(word, nVowel-2, nVowel-2) == 'ʰ' and iStops[mw.ustring.sub(word, nVowel-3, nVowel-3)] then
  					sBreak = nVowel - 4
  				else
  					sBreak = nVowel - 2
  				end
  			elseif iCons[mw.ustring.sub(word, nVowel-1, nVowel-1)] then
  				sBreak = nVowel - 2
  			elseif mw.ustring.sub(word, nVowel-1, nVowel-1) == 'ʰ' and iStops[mw.ustring.sub(word, nVowel-2, nVowel-2)] then
  				sBreak = nVowel - 3
  			elseif mw.ustring.sub(word, nVowel-1, nVowel-1) == '̥' and mw.ustring.sub(word, nVowel-2, nVowel-2) == 'r' then
  				sBreak = nVowel - 3
  			else
  				sBreak = nVowel - 1
  			end

  			--Pull everything up to and including the syllable Break.
  			local syllable = mw.ustring.sub(word, 1, sBreak)

  			--If there is a stress accent, then we need to move it to the
  			--beginning of the syllable, unless it is a monosyllabic word,
  			--in which case we remove it altogether.
  			if stress then
  				if next(syllables) or syllable ~= word then
  					syllable = 'ˈ'..mw.ustring.gsub(syllable, 'ˈ', '')
  				else
  					syllable = mw.ustring.gsub(syllable, 'ˈ', '')
  				end
  				stress = false
  			end
  			table.insert(syllables, syllable)
  			word = mw.ustring.sub(word, sBreak+1)
  		end

  		if #syllables &gt; 0 then
  			IPAs[period].IPA = table.concat(syllables, '.')
  		end
  	end

  	--Final format
  	local inlineProns = '&lt;div class=&quot;showme&quot; style=&quot;display:none&quot;&gt;\n* IPA:'
  	for i=1, #inlinePeriods do
  		period = inlinePeriods[i]
  		inlineProns = inlineProns..'&lt;span class=&quot;IPA&quot; lang=&quot;grc&quot;&gt;/'..IPAs[period].IPA..'/&lt;/span&gt;'
  		if period ~= 'byz2' then
  			inlineProns = inlineProns..' &rarr; '
  		end
  	end
  	local inlineProns = inlineProns..'&lt;/div&gt;'
  	local fullProns = '&lt;div class=&quot;hideme&quot;&gt;\n'
  	for i=1, #periods do
  		period = periods[i]
  		local notes = ''
  		if #IPAs[period].notes &gt; 0 then
  			notes = '  &lt;span class=&quot;previewonly&quot;&gt;'..table.concat(IPAs[period].notes, ', ')..'&lt;/span&gt;'
  		end
  		fullProns = fullProns..'* '..periodLabels[period]..': IPA: &lt;span class=&quot;IPA&quot; lang=&quot;grc&quot;&gt;/'..IPAs[period].IPA..'/&lt;/span&gt;'..notes
  		if period ~= 'byz2' then
  			fullProns = fullProns..'\n'
  		end
  	end
  	fullProns = fullProns..'&lt;/div&gt;'
  	local final = '&lt;div class=&quot;vsSwitcher vsClass-pronunciations&quot;&gt;&lt;span class=&quot;putButtonHere&quot; style=&quot;float:right&quot;&gt;&amp;nbsp;&lt;/span&gt;'..inlineProns..fullProns..'&lt;/div&gt;'
  	return final
  end

  return export
  --Things we still need:
  --Voicing of sigma around (after?) voiced stops.
  --Proper alerts for editors, especially on ambiguous vowels.

        </code>
      </pre>
    </figure>
  </div>

  <div id="projectDisplay4" class="hiddenProject">
    <div><span>Title: </span><span>Quotations</span></div>
    <div><span>Language: </span><span>Lua</span></div>
    <div><span>Purpose: </span><span>Formats and displays an illustrative quotation for a definition on Wiktionary.</span></div>
    <div><span>Description: </span><span>This is a top level script which is meant to do basic formatting for quotations in any language.  It has the ability to rely on language specific helper modules if they are written
    for a given language (such as <a href="https://en.wiktionary.org/w/index.php?title=Module:Quotations/grc&oldid=24555610">Ancient Greek</a>),
    which may or may not incorporate a corpus database (such as <a href="https://en.wiktionary.org/wiki/Module:Quotations/grc/data">Ancient Greek</a>).  The script provides the primary logic for the Q template, which
    can be seen in use at <a href="https://en.wiktionary.org/wiki/%CE%B4%CE%B7%CE%BC%CE%BF%CE%BA%CF%81%CE%B1%CF%84%CE%AF%CE%B1#Ancient%20Greek">δημοκρατία</a> under the second Ancient Greek definition.
    The displayed code is from <a href="https://en.wiktionary.org/w/index.php?title=Module:Quotations&oldid=26331926">the latest edit I made</a>, at which point I had authored the majority of the code.
    The <a href="https://en.wiktionary.org/wiki/Module:Quotations">current version</a> has undergone significant changes (likely improvements).</span></div>
    <figure>
      <pre>
<code>
  local m_scriptutils = require(&quot;Module:script utilities&quot;)
  local m_utilities = require(&quot;Module:utilities&quot;)
  local date_validation = require(&quot;Module:Quotations/date validation&quot;)
  local loadModule = nil -- essentially a forward-declaration
  local export = {}

  function export.create(frame)
  	local passed = true
  	local results = ''
  	passed, results = pcall(export.Create, frame)
  	if passed then
  		return results
  	else
  		return '&lt;span class=&quot;wiktQuote previewonly&quot; data-validation=&quot;red&quot;&gt;'..results..'&lt;/span&gt;'
  	end
  end

  function export.Create(frame)
  	--Set up our initial variables.
  	local args = frame:getParent().args
  	--Set empty tags to false
  		for k,v in pairs(args) do
  			if v == '' then
  				args[k] = false
  			end
  		end
  	local codedLangs = {['grc'] = true, ['la'] = true, ['xcl'] = true, ['hy'] = true, ['axm'] = true}
  	local lang = args[1]; if lang == &quot;&quot; then lang = nil end
  	lang = require(&quot;Module:languages&quot;).getLanguageByCode(lang)

  	local ante = {}

  	if codedLangs[lang:getCode()] then
  		local m_langModule = loadModule(lang)
  		ante = m_langModule.expand(args)
  	else
  		ante.author = args[2]
  		ante.work = args[3]
  		ante.ref = ''
  		local dot = false
  		for i=4, 10 do
  			if args[i] then
  				ante.ref = ante.ref..(dot and '.' or '')..args[i]
  				dot = true
  			else
  				break
  			end
  		end
  		for k,v in pairs(args) do
  			if type(k) ~= 'number' then
  				ante[k] = args[k]
  			end
  		end
  	end
  	local penult = {['year'] = '', ['author'] = '', ['work'] = '', ['ref'] = '',
  		['notes'] = '', ['otherLines'] = '', ['s1'] = '', ['s2'] = '',
  		['s3'] = '', ['s4'] = ''}
  	local comma = false
  	--Language specific modules are responsible for first line parameters.
  	--Base formatting module will poll for other parameters,
  	--pulling them only if the language module hasn't returned them.

  	local otherOtherLineStuff = {'quote', 'transyear', 'transauthor', 'trans'}
  	for i=1, 4 do
  		ante[otherOtherLineStuff[i]] = ante[otherOtherLineStuff[i]] or args[otherOtherLineStuff[i]]
  	end

  	if not ante.code then
  		penult.elAttr = ' class=&quot;wiktQuote&quot; data-validation=&quot;white&quot;&gt;'
  	else
  		penult.elAttr = ' class=&quot;wiktQuote&quot; data-validation=&quot;'..ante.code..'&quot;&gt;'
  	end
  	if ante.year then
  		penult.year = &quot;'''&quot;..date_validation.main(ante.year)..&quot;'''&quot;
  		comma = true
  	end
  	if ante.author then
  		penult.s1 = (comma and ', ' or '')
  		penult.author = ante.author
  		comma = true
  	end
  	if ante.work then
  		penult.s2 = (comma and ', ' or '')
  		penult.work = &quot;''&quot;..ante.work..&quot;''&quot;
  		comma = true
  	end
  	if ante.ref then
  		penult.s3 = (comma and ' ' or '')
  		penult.ref = ante.ref
  	end
  	if ante.notes then
  		penult.s4 = (comma and', ' or '')
  		penult.notes = '('..ante.notes..')'
  	end
  	if ante.quote or ante.trans then
  		penult.otherLines = '&lt;dl&gt;&lt;dd&gt;'
  		if ante.quote then
  			local sc, scFix = m_utilities.detect_script(ante.quote, lang)
  			penult.otherLines = penult.otherLines..m_scriptutils.tag_text(ante.quote, lang, sc)
  		end
  		if ante.trans then
  			if ante.transyear or ante.transauthor then
  				penult.otherLines = penult.otherLines..'&lt;ul&gt;&lt;li&gt;'
  				if ante.transyear then
  					penult.otherLines = penult.otherLines..&quot;'''&quot;..ante.transyear..&quot;''' translation&quot;
  				else
  					penult.otherLines = penult.otherLines..'Translation'
  				end
  				if ante.transauthor then
  					penult.otherLines = penult.otherLines..' by '..ante.transauthor
  				end
  				penult.otherLines = penult.otherLines..'&lt;dl&gt;&lt;dd&gt;'..ante.trans..'&lt;/dd&gt;&lt;/dl&gt;&lt;/li&gt;&lt;/ul&gt;'
  			else
  				if not ante.quote then
  					penult.otherLines = penult.otherLines..ante.trans
  				else
  					penult.otherLines = penult.otherLines..'&lt;dl&gt;&lt;dd&gt;'..ante.trans..'&lt;/dd&gt;&lt;/dl&gt;'
  				end
  			end
  		end
  		penult.otherLines = penult.otherLines..'&lt;/dl&gt;&lt;/dd&gt;'
  	end
  	local form = args['form'] or 'full'
  	if form == 'full' then
  		ultimate = '&lt;div'..penult.elAttr..penult.year..penult.s1..penult.author..penult.s2..penult.work..penult.s3..penult.ref..penult.s4..penult.notes..penult.otherLines..'&lt;/div&gt;'
  	elseif form == 'inline' then
  		ultimate = '&lt;span'..penult.elAttr..penult.author..penult.s2..penult.work..penult.s3..penult.ref..'&lt;/span&gt;'
  	elseif form == 'work' then
  		ultimate = '&lt;span'..penult.elAttr..penult.work..penult.s3..penult.ref..'&lt;/span&gt;'
  	elseif form == 'ref' then
  		ultimate = '&lt;span'..penult.elAttr..penult.ref..'&lt;/span&gt;'
  	end
  	return ultimate

  end

  function loadModule(lang)
  	local sema = require('Module:Quotations/' .. lang:getCode())
  	sema.library = sema.library or mw.loadData(&quot;Module:Quotations/&quot; .. lang:getCode() .. &quot;/data&quot;)

  	sema.changeCode = sema.changeCode or function(color)
  		if color == 'orange' then
  			sema.code = 'orange'
  		end
  		if (color == 'yellow') and (sema.code == 'green') then
  			sema.code = 'yellow'
  		end
  	end

  	sema.reroute = sema.reroute or function(route)
  		local temp = {}
  		local data = sema.library.data

  		for k,v in pairs(route) do
  			temp[k] = sema.interpret(v)
  		end

  		for k, v in pairs(temp) do
  			sema[k] = v
  		end

  		if sema.author ~= nil and data[sema.author] then
  			sema.aData = data[sema.author]
  			if sema.work ~= nil and sema.aData.works[sema.work] then
  				sema.wData = sema.aData.works[sema.work]
  			end
  		end
  	end

  	sema.choose = sema.choose or function(choice, optionA, optionB)
  		optionB = optionB or ''
  		choice = sema.interpret(choice)
  		local chosenPath = {}
  		if choice then
  			chosenPath = optionA
  		else
  			chosenPath = optionB
  		end
  		for j=1, 30 do
  			local innerCurrent = chosenPath[j]
  			if innerCurrent then
  				table.insert(sema.refLink, sema.interpret(current))
  			else
  				break
  			end
  		end
  		local ongoingDecision
  		decision = sema.interpret(decision)
  		return decision
  	end

  	sema.isLetter = sema.isLetter or function(input)
  		local isit = not tonumber(input)
  		return isit
  	end

  	sema.lower = sema.lower or mw.ustring.lower

  	sema.roundDown = sema.roundDown or function(period, verse)
  		if not tonumber(verse) then
  			sema.changeCode('orange')
  		else
  			local rounded = math.floor(verse/period) * period
  			return rounded
  		end
  	end

  	sema.chapterSelect = sema.chapterSelect or function(rubric, verse)
  		verse = tonumber(verse)
  		for k,v in pairs(rubric) do
  			if v[1] &lt;= verse and verse &lt;= v[2] then
  				return k
  			end
  		end
  		sema.changeCode('orange')
  	end

  	sema.interpret = sema.interpret or function(item)
  		if type(item) == 'string' then
  			if string.sub(item, 1, 1) == '.' then
  				address = string.sub(item, 2)
  				local returnable = sema[address] or sema.library.data.Sundry and sema.library.data.Sundry[address]
  				return returnable
  			else
  				return item
  			end
  		elseif type(item) == 'table' then
  		--If it's a table, it's either a function call or a nested address.
  			local presumedFunction = sema.interpret(item[1])
  			if type(presumedFunction) == 'function' then
  				local parameters = {}
  				for i=2, 30 do
  					if item[i] ~= null then
  						local expanded = sema.interpret(item[i])
  						table.insert(parameters, expanded)
  					else
  						break
  					end
  				end
  				local result = presumedFunction(unpack(parameters))
  				return result
  			else
  				local nested = sema
  				for i=1, 30 do
  					local address = item[i]
  					if address then
  						nested = nested[address]
  					else
  						break
  					end
  				end
  				return nested
  			end
  		else
  			return item
  		end
  	end

  	sema.convert = sema.convert or function(scheme, initiate)
  		if type(scheme) == &quot;table&quot; then
  			local initiate = tonumber(initiate) or initiate
  			local converted = scheme[initiate]
  			if converted == nil then
  				sema.changeCode('orange')
  			end
  			return converted
  		end
  		if type(scheme) == &quot;function&quot; then
  			local initiate = tonumber(initiate) or initiate
  			local converted = scheme(initiate)
  			if converted == nil then
  				sema.changeCode('orange')
  			end
  			return converted
  		end
  		sema.changeCode('orange')
  	end

  	sema.numToRoman = sema.numToRoman or function(item)
  		local j = tonumber(item)
  		if (j == nil) then
  			return item
  		end
  		if (j &lt;= 0) then
  			return item
  		end

  		local ints = {1000, 900,  500, 400, 100,  90, 50,  40, 10,  9,   5,  4,   1}
  		local nums = {'M',  'CM', 'D', 'CD','C', 'XC','L','XL','X','IX','V','IV','I'}

  		local result = &quot;&quot;
  		for k = 1, #ints do
  			local count = math.floor(j / ints[k])
  			result = result .. string.rep(nums[k], count)
  			j = j - ints[k]*count
  		end
  		return result
  	end

  	sema.period = sema.period or '.'

  	sema.expand = sema.expand or function(args)
  		--Instantiate our variables.
  		local results = {}
  		sema.code = 'green'
  		local data = sema.library.data
  		local ultimate = ''



  		sema.author = args['author'] or args[2]
  		sema.work = args['work'] or args[3]
  		for i=1, 5 do
  			local refName = 'ref'..tostring(i)
  			local paramNumber = i + 3
  			sema[refName] = args[refName] or args[paramNumber]
  		end
  		--Check if we've been given an author alias.
  		if data.authorAliases[sema.author] then
  			sema.author = data.authorAliases[sema.author]
  		end

  		if not data[sema.author] then
  			sema.changeCode('yellow')
  		else
  			sema.aData = data[sema.author]
  			if sema.aData.reroute then
  				sema.reroute(sema.aData.reroute)
  			else
  				if sema.aData.aliases and sema.aData.aliases[sema.work] then
  					sema.work = sema.aData.aliases[sema.work]
  				end
  				if not sema.aData.works or not sema.aData.works[sema.work] then
  					sema.changeCode('yellow')
  				else
  					sema.wData = sema.aData.works[sema.work]
  					if sema.wData.reroute then
  						sema.reroute(sema.wData.reroute)
  					end
  				end
  			end
  		end

  		--Load all author-level data.
  		if sema.aData and sema.aData.aLink then
  			results.author = '[[w:'..sema.aData.aLink..'|'..sema.author..']]'
  		else
  			results.author = sema.author
  		end
  		if sema.aData and sema.aData.year then
  			results.year = sema.aData.year
  		end

  		--If the database has a link for the work, incorporate it.
  		if not sema.wData or not sema.wData['wLink'] then
  			results.work = sema.work
  		else
  			results.work = '[[w:'..sema.wData['wLink']..'|'..sema.work..']]'
  		end
  		--Some works have info which overrides the author-level info.
  		if sema.wData then
  			if sema.wData['year'] then
  			results.year = sema.wData.year
  			end
  			if sema.wData['author'] ~= nil then
  				results.author = sema.wData.author
  			end
  		end
  		--The displayed reference is simply all the ref argument(s) joined with a period.
  		sema.refDisplay = sema.ref1 and '' or false
  		for i=1, 5 do
  			local whichRef = 'ref'..tostring(i)
  			if sema[whichRef] then
  				if i &gt; 1 then
  					sema.refDisplay = sema.refDisplay..'.'
  				end
  				sema.refDisplay = sema.refDisplay..sema[whichRef]
  			else
  				break
  			end
  		end
  		if args['through'] then
  			args['thru'] = args['through']
  		end
  		if args['thru'] then
  			sema.refDisplay = sema.refDisplay..'&ndash;'..args['thru']
  		end
  		--If the work is not in the database, or we don't have a source text link,
  		--the ref is simply the display.
  		--Otherwise, we have to create a reference link,
  		--easily the most challenging function of this script.
  		if sema.wData and sema.wData['rlFormat'] then
  			sema.rlFormat = sema.aData['rlFormat'..tostring(sema.wData.rlFormat)]
  			if sema.rlFormat then
  				sema.rlTitle = sema.wData['rlTitle']
  				sema.refLink = {}
  				for i=1, 30 do
  					local current = sema.rlFormat[i]
  					if current then
  						table.insert(sema.refLink, sema.interpret(current))
  					else
  						break
  					end
  				end
  				sema.refLink = table.concat(sema.refLink)
  			end
  		end
  		if sema.refLink then
  			results.ref = '[['..sema.refLink..'|'..sema.refDisplay..']]'
  		else
  			results.ref = sema.refDisplay
  		end
  		if args['notes'] then
  			results.notes = args.notes
  		end
  		results.code = sema.code
  		return results

  	end

  	return sema
  end

  return export

        </code>
      </pre>
    </figure>
  </div>

  <div id="projectDisplay5" class="hiddenProject">
    <div><span>Title: </span><span>Tag Deletion Report</span></div>
    <div><span>Language: </span><span>Javascript</span></div>
    <div><span>Purpose: </span><span>Analyzes deleted items and creates a list of ones meeting specific criteria.</span></div>
    <div><span>Description: </span><span>This script works as a bookmarklet which processes a pdf
      converted by <a href="https://mozilla.github.io/pdf.js/">pdf.js</a>.  The pdf which it works on is a computer generated report
      which uses a monowidth font, an attribute which the script makes ample use of in determining where strings should begin and end
      and what sort of information they represent.  It was written as a way to automate a task I had previously done by hand, saving me
      roughly an hour a week.</span></div>
    <figure>
      <pre>
<code>
  javascript:{
  function numberWithCommas(x) {
      return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, &quot;,&quot;);
  }
  var pdf = document.getElementById(&quot;viewer&quot;);
  var numPages = pdf.childNodes.length;
  var dataArray = [];
  for(i=0; i&lt;numPages; i++) {
  	var page = pdf.childNodes[i];
  	var pageText = page.getElementsByClassName(&quot;textLayer&quot;)[0];
  	var lines = pageText.childNodes;
  	var atTags = false;
  	for (j=0; j&lt;lines.length; j++) {
  		var line = lines[j];
  		lineText = line.innerHTML;
  		if (atTags) {
  			var thisTagArray = [];
  			lineText = lineText.replace(/&amp;amp;/g, &quot;&amp;&quot;);
  			thisTagArray.push(lineText.substring(0,17));
  			thisTagArray.push(lineText.substring(18,26));
  			thisTagArray.push(lineText.substring(27,47));
  			thisTagArray.push(lineText.substring(48,60));
  			thisTagArray.push(lineText.substring(61,65));
  			thisTagArray.push(lineText.substring(66,85));
  			thisTagArray.push(lineText.substring(86,89));
  			thisTagArray.push(lineText.substring(90,93));
  			thisTagArray.push(lineText.substring(94,107));
  			thisTagArray.push(lineText.substring(108,116));
  			thisTagArray.push(lineText.substring(117,138));
  			thisTagArray.push(lineText.substring(139,149));
  			dataArray.push(thisTagArray);
  			}
  		else if (lineText.substring(0, 7) == &quot;-------&quot;) {
  			atTags = true;
  			}
  		}
  	}
  var totalRetail = 0;
  var totalItemCount = 0;
  var drTracker = {};
  var flaggedTags = [];
  var certainDeleteFlags = [&quot;Lost&quot;, &quot;Invalid SKU&quot;, &quot;Voided Transaction&quot;, &quot;Duplicate&quot;];
  var uncertainDeleteFlags = [&quot;Resell at Full Price&quot;, &quot;Reduce Tag&quot;];
  for (i=0; i&lt;dataArray.length; i++) {
  	var item = dataArray[i];
  	if (item.length == 12 &amp;&amp; item[0].trim() != &quot;&quot;) {
  		var tagNumber = item[0].trim();
  		var price = item[8].trim();
  		if (!isNaN(tagNumber) &amp;&amp; !isNaN(price)) {
  			price = Number(price);
  			totalRetail += price;
  			totalItemCount += 1;
  			var delReason = item[10].trim();
  			if (drTracker[delReason]) {
  				drTracker[delReason][&quot;price&quot;] += price;
  				drTracker[delReason][&quot;count&quot;] += 1;
  				}
  			else {
  				drTracker[delReason] = {};
  				drTracker[delReason][&quot;price&quot;] = price;
  				drTracker[delReason][&quot;count&quot;] = 1;
  				}
  			if (certainDeleteFlags.indexOf(delReason) != -1) {
  				flaggedTags.push(item);
  				}
  			else if (uncertainDeleteFlags.indexOf(delReason) != -1 &amp;&amp; item[1].trim() != &quot;&quot;) {
  				flaggedTags.push(item);
  				}
  			}
  		}
  	}
  var head= document.getElementsByTagName(&quot;head&quot;)[0];
  head.innerHTML = &quot;&lt;style&gt;
  @media print{@page {size: landscape}}
  h1 {text-align: center;}
  h2 {text-align: center;}
  tr {text-align: center;}
  &lt;/style&gt;&quot;;
  var body = document.getElementsByTagName(&quot;body&quot;)[0];
  body.innerHTML = &quot;&lt;h1&gt;Tag Deletion Report&lt;/h1&gt;&quot;;
  var totalHeader = document.createElement(&quot;h2&quot;);
  totalHeader.innerHTML = &quot;Total: $&quot; + numberWithCommas(totalRetail.toFixed(2)) + &quot; - &quot; + totalItemCount + &quot; items&quot;;
  body.appendChild(totalHeader);
  var breakdownHeader = document.createElement(&quot;h2&quot;);
  breakdownHeader.innerHTML = &quot;Breakdown&quot;;
  body.appendChild(breakdownHeader);
  var delReasons = Object.keys(drTracker);
  var breakdownTable = document.createElement(&quot;table&quot;);
  breakdownTable.style = &quot;width:100%&quot;;
  breakdownTableRow1 = document.createElement(&quot;tr&quot;);
  for (i=0; i&lt;delReasons.length; i++) {
  	var thisCell = document.createElement(&quot;td&quot;);
  	thisCell.innerHTML = delReasons[i];
  	breakdownTableRow1.appendChild(thisCell);
  	}
  breakdownTable.appendChild(breakdownTableRow1);

  breakdownTableRow2 = document.createElement(&quot;tr&quot;);
  for (i=0; i&lt;delReasons.length; i++) {
  	var thisCell = document.createElement(&quot;td&quot;);
  	thisCell.innerHTML = &quot;$&quot; + numberWithCommas(drTracker[delReasons[i]][&quot;price&quot;].toFixed(2));
  	breakdownTableRow2.appendChild(thisCell);
  	}
  breakdownTable.appendChild(breakdownTableRow2);

  breakdownTableRow3 = document.createElement(&quot;tr&quot;);
  for (i=0; i&lt;delReasons.length; i++) {
  	var thisCell = document.createElement(&quot;td&quot;);
  	thisCell.innerHTML = numberWithCommas(drTracker[delReasons[i]][&quot;count&quot;]);
  	breakdownTableRow3.appendChild(thisCell);
  	}
  breakdownTable.appendChild(breakdownTableRow3);
  body.appendChild(breakdownTable);
  var flagTagHeader = document.createElement(&quot;h2&quot;);
  flagTagHeader.innerHTML = &quot;Flagged Tags&quot;;
  body.appendChild(flagTagHeader);
  var flagTagTable = document.createElement(&quot;table&quot;);
  flagTagTable.border = &quot;1&quot;;
  var flagTagRow1 = document.createElement(&quot;tr&quot;);
  flagTagRow1.innerHTML = '&lt;td&gt;Tag #&lt;/td&gt;&lt;td&gt;Merch Type&lt;/td&gt;&lt;td&gt;Delete Reason&lt;/td&gt;&lt;td style=&quot;width:99%&quot;&gt;Explanation&lt;/td&gt;';
  flagTagTable.appendChild(flagTagRow1);
  for (i=0; i&lt;flaggedTags.length; i++) {
  	var thisItem = flaggedTags[i];
  	var PO = thisItem[1].trim();
  	if (PO == &quot;&quot;) {
  		var merchType = &quot;R&quot;;
  		}
  	else if (PO.substring(0,3) == &quot;065&quot; &amp;&amp; Number(PO.substring(3,4)) &lt; 7) {
  		var merchType = &quot;S&quot;;
  		}
  	else {
  		var merchType = &quot;C&quot;;
  		}
  	delReason = thisItem[10].trim();
  	var thisFlagTagRow = document.createElement(&quot;tr&quot;);
  	thisFlagTagRow.innerHTML = '&lt;td&gt;' + thisItem[0].trim() + '&lt;/td&gt;&lt;td&gt;' + merchType + '&lt;/td&gt;&lt;td&gt;' + delReason + '&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;';
  	flagTagTable.appendChild(thisFlagTagRow);
  	}
  body.appendChild(flagTagTable);
  }
        </code>
      </pre>
    </figure>
  </div>

  <div id="projectDisplay6" class="hiddenProject">
    <div><span>Title: </span><span>Purchase Journal Report</span></div>
    <div><span>Language: </span><span>Javascript</span></div>
    <div><span>Purpose: </span><span>Checks all purchase orders received by the store, noting orders that meet certain criteria.</span></div>
    <div><span>Description: </span><span>This function is similar to the Tag Deletion Report, in that it is a bookmarklet which processes a pdf.js converted monowidth report
      into another report which would normally be done by hand.  This script saved me roughly 15-20 hours a month.  The most notable improvement over the
      Tag Deletion Report script is the addition of a self scrolling feature (the browser only actually loads pages within five or so pages of the currently viewed
      page, so the script has to actually scroll the page and then wait for half a second to ensure the data is loaded). </span></div>
    <figure>
      <pre>
<code>
  javascript:{

 var pdf = document.getElementById(&quot;viewer&quot;);
 var numPages = pdf.childNodes.length;
 var dataArray = [];
 var pdfContainer = document.getElementById(&quot;viewerContainer&quot;);
 var pageHeight = pdfContainer.scrollHeight/numPages;
 var pageTracker = 0;
 var date = {};
 var dataArray = {};
 var monthNames = ['', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
 var currentDept = '';
 var checkedPOs = [];
 var anomalies  = {};
 var worthwhilePOTypes = ['Transfer', 'S/O', 'SFI', 'DC', 'DTS', 'Other'];
 var depts = [];
 var deptTotals = {};
 var importantVendors = ['DTS ALEXANDRIA MOULDING', 'DTS AXXESS ENTRY TECHNOLOGIE', 'LIBERTY', 'DTS QUIKRETE COMPANIES', 'DTC OLDCASTLE ARCHITECTURAL,', 'DTS PRIMO WATER'];
 var vendorTotals = {};
 var SODepartments = ['23', '29', '30', '59'];
 var SODepartmentTotals = {};
 initialize();
 readPage();

 function moneyFormat(x) {
 	x = x.toFixed(2);
     return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, &quot;,&quot;);
 	}

 function initialize() {
 	for (i=0; i&lt;importantVendors.length; i++) {
 		vendor = importantVendors[i];
 		vendorTotals[vendor] = [0, 0];
 		}
 	for (i=0; i&lt;SODepartments.length; i++) {
 		dept = SODepartments[i];
 		SODepartmentTotals[dept] = 0;
 		}
 	var page = pdf.childNodes[0];
 	var pageText = page.getElementsByClassName(&quot;textLayer&quot;)[0];
 	var lines = pageText.childNodes;
 	var thirdLine = lines[2];
 	var thirdLineText = thirdLine.innerHTML;
 	var startDate = thirdLineText.substring(63,73);
 	var endDate = thirdLineText.substring(77,87);
 	var monthSuspect = 0;
 	var month = 0;
 	var year = '';
 	monthName = '';

 	if (Number(startDate.substring(3,5)) &gt; 21) {
 		monthSuspect = Number(startDate.substring(0,2)) + 1;
 		}
 	else if (Number(startDate.substring(3,5)) &lt; 8) {
 		monthSuspect = Number(startDate.substring(0,2));
 		}
 	if (Number(endDate.substring(3,5)) &gt; 21) {
 		if (monthSuspect == Number(endDate.substring(0,2))) {
 			month = monthSuspect;
 			year = endDate.substring(6,10);
 			}
 		}
 	else if (Number(endDate.substring(3,5)) &lt; 8) {
 		if (endDate.substring(0,2) == '01' &amp;&amp; monthSuspect == 12) {
 			month = monthSuspect;
 			year = startDate.substring(6,10);
 			}
 		else if (monthSuspect == Number(endDate.substring(0,2))-1) {
 			month = monthSuspect;
 			year = startDate.substring(6,10);
 			}
 		}
 	if (month &gt; 0) {
 		monthName = monthNames[month];
 		}
 	date['monthNumber'] = month;
 	date[&quot;month&quot;] = monthName;
 	date[&quot;year&quot;] = year;
 	}

 function readPage () {
 	if (pageTracker &lt; numPages) {
 		pdfContainer.scrollTop = pageHeight * pageTracker;
 		var page = pdf.childNodes[pageTracker];
 		if (page.getElementsByClassName(&quot;textLayer&quot;)[0] &amp;&amp; page.getElementsByClassName(&quot;textLayer&quot;)[0].childNodes.length &gt; 1) {
 			var pageText = page.getElementsByClassName(&quot;textLayer&quot;)[0];
 			var lines = pageText.childNodes;
 			var dept = lines[4].innerHTML.substring(15,17);
 			if (currentDept != dept) {
 				checkedPOs = [];
 				currentDept = dept;
 				depts.push(dept);
 				deptTotals[dept] = {};
 				for (i=0; i&lt;worthwhilePOTypes.length; i++) {
 					var currentPOType = worthwhilePOTypes[i];
 					deptTotals[dept][currentPOType] = [0,0];
 					}
 				anomalies[currentDept] = {duplicate:[], IMU:{}, big:[]};
 				}
 			if (lines[6].innerHTML.substring(47,59) == 'Order number') {
 				for (j=9; j&lt;lines.length-1; j=j+2) {
 					var firstLine = lines[j].innerHTML.replace(/&amp;amp;/g, &quot;&amp;&quot;);
 					var firstLine = firstLine.replace(/&amp;lt;/g, &quot;&lt;&quot;);
 					var secondLine = lines[j+1].innerHTML.replace(/&amp;amp;/g, &quot;&amp;&quot;);
 					var secondLine = secondLine.replace(/&amp;lt;/g, &quot;&lt;&quot;);
 					var PO = firstLine.substring(48,58).trim();
 					var vendor = firstLine.substring(0,28).trim();
 					var cost = firstLine.substring(72,86).trim();
 					var discount = secondLine.substring(72,82).trim().replace(/&lt;/g, '');
 					if (!isNaN(Number(discount)) &amp;&amp; discount != '') {
 						cost = discount;
 						}
 					cost = Number(cost);
 					if (isNaN(cost)) {
 						cost = 0;
 						}
 					var retail = firstLine.substring(87,99);
 					retail = Number(retail);
 					if (isNaN(retail)) {
 						retail = 0;
 						}
 					var type = '';
 					if (PO.substring(0,3) == '067') {
 						type = 'Transfer';
 						}
 					else if (PO.substring(0,3) == '065') {
 						type = 'S/O'
 						}
 					else if (PO.substring(0,3) == '064') {
 						type = 'SFI';
 						}
 					else if (PO.substring(0,2) == '85' || PO.substring(0,3) == '200') {
 						type = 'DC';
 						}
 					else if (PO.substring(0,3) == '060' || PO.substring(0,3) == '069') {
 						type = 'DTS';
 						}
 					else if (!isNaN(Number(PO)) &amp;&amp; PO != '') {
 						type = 'Other';
 						}
 					if 	(worthwhilePOTypes.indexOf(type) &gt; -1) {

 						deptTotals[currentDept][type][0] += cost;
 						deptTotals[currentDept][type][1] += retail;
 						if (checkedPOs.indexOf(PO) &gt; -1 &amp;&amp; vendor.substring(0,2) != 'DC' &amp;&amp; PO!= '') {
 							anomalies[currentDept]['duplicate'].push([PO, pageTracker + 1]);
 							}
 						else {
 							checkedPOs.push(PO);
 							}
 						if (Number(cost) &gt; Number(retail)) {
 							if (anomalies[currentDept]['IMU'][type]) {
 								anomalies[currentDept]['IMU'][type].push([PO, pageTracker + 1]);
 								}
 							else {
 								anomalies[currentDept]['IMU'][type] = [];
 								anomalies[currentDept]['IMU'][type].push([PO, pageTracker + 1]);
 								}
 							}
 						if (Number(cost) &gt; 25000 || Number(retail) &gt; 25000) {
 							anomalies[currentDept]['big'].push([PO, pageTracker + 1]);
 							}
 						}
 					for (k=0; k&lt;importantVendors.length; k++) {
 						thisVendor = importantVendors[k];
 						if (vendor.indexOf(thisVendor) &gt; -1){
 							vendorTotals[thisVendor][0] += Number(cost);
 							}
 						}
 					}
 				}
 			else if (lines[6].innerHTML.substring(37,47) == 'RTV number') {
 				for (j=8; j&lt;lines.length-1; j=j+2) {
 					var firstLine = lines[j].innerHTML.replace(/&amp;amp;/g, &quot;&amp;&quot;);
 					var secondLine = lines[j+1].innerHTML.replace(/&amp;amp;/g, &quot;&amp;&quot;);
 					var vendor = firstLine.substring(0,28).trim();
 					var cost = firstLine.substring(70,82).trim();
 					var retail = firstLine.substring(83,95).trim();
 					for (k=0; k&lt;importantVendors.length; k++) {
 						thisVendor = importantVendors[k];
 						if (vendor.indexOf(thisVendor) &gt; -1){
 							vendorTotals[thisVendor][1] += Number(cost);
 							}
 						}
 					if (SODepartments.indexOf(currentDept) &gt; -1 &amp;&amp; vendor.indexOf('S/O') &gt; -1) {
 						SODepartmentTotals[currentDept] += Number(cost);
 						}
 					}
 				}
 			pageTracker += 1;
 			setTimeout(readPage, 500);
 			}

 		else {
 			pageTracker += 1;
 			setTimeout(readPage, 500);
 			}
 		}
 	else {
 		var head= document.getElementsByTagName(&quot;head&quot;)[0];
 		head.innerHTML = &quot;&lt;style&gt;
 		@media print{@page {size: landscape}}
 		h1 {text-align: center;}
 		h3 {text-align: center;}
 		table {width:100%; border:2px solid black; border-collapse:collapse;font-size: 110%;font-family:Arial, Helvetica, sans-serif}
 		td {text-align: center;border:2px solid black;height:2em}
 		.bold {font-weight: bold;}
 		.floatLeft {float: left}
 		.floatRight {float: right}
 		.clearBoth { clear: both}
 		.nobr { white-space: nowrap; }
 		#creditTable {table-layout: fixed;}
 		&lt;/style&gt;&quot;;
 		var body = document.getElementsByTagName(&quot;body&quot;)[0];
 		body.innerHTML = '';
 		var topTable = document.createElement(&quot;table&quot;);
 		topTable.className = 'bold';
 		var topTableFirstRow = document.createElement('tr');
 		var topTableFirstRowCell = document.createElement('td');
 		topTableFirstRowCell.innerHTML = 'Purchase Journal Checklist for ' + date['month'] + ' ' + date['year'];
 		topTableFirstRow.appendChild(topTableFirstRowCell);
 		var topTableSecondRow = document.createElement('tr');
 		var topTableSecondRowCell = document.createElement('td');
 		var currentDate = new Date();
 		topTableSecondRowCell.innerHTML = 'Prepared on ' + currentDate.toDateString();
 		topTableSecondRow.appendChild(topTableSecondRowCell);
 		body.appendChild(topTable);
 		topTable.appendChild(topTableFirstRow);
 		topTable.appendChild(topTableSecondRow);
 		body.innerHTML += '&lt;h3&gt;RTV Credit Verification&lt;/h3&gt;';
 		var creditTable = document.createElement('table');
 		creditTable.id = 'creditTable';
 		var creditMonthRow = document.createElement('tr');
 		var firstMonthCell = document.createElement('td');
 		creditMonthRow.appendChild(firstMonthCell);
 		var secondMonthCell = document.createElement('td');
 		secondMonthCell.innerHTML = date['month'];
 		creditMonthRow.appendChild(secondMonthCell);
 		var thirdMonthCell = document.createElement('td');
 		var lastMonthNumber = date['monthNumber']-1;
 		if (lastMonthNumber == 0) {lastMonthNumber = 12;}
 		thirdMonthCell.innerHTML = monthNames[lastMonthNumber];
 		creditMonthRow.appendChild(thirdMonthCell);
 		var fourthMonthCell = document.createElement('td');
 		var lastLastMonthNumber = lastMonthNumber-1;
 		if (lastLastMonthNumber == 0) {lastLastMonthNumber = 12;}
 		fourthMonthCell.innerHTML = monthNames[lastLastMonthNumber];
 		creditMonthRow.appendChild(fourthMonthCell);
 		creditTable.appendChild(creditMonthRow);
 		body.appendChild(creditTable);
 		for(i=0; i&lt;importantVendors.length; i++) {
 			var thisRow = document.createElement('tr');
 			creditTable.appendChild(thisRow);
 			vendor = importantVendors[i];
 			var percentage = 0;
 			if (vendorTotals[vendor][0] != 0) {
 				percentage = Math.round((vendorTotals[vendor][1]/vendorTotals[vendor][0])*10000)/100;
 				}
 			var firstCell = document.createElement('td');
 			firstCell.innerHTML = vendor + ':';
 			thisRow.appendChild(firstCell);
 			var secondCell = document.createElement('td');
 			secondCell.innerHTML = moneyFormat(percentage) + '%';
 			thisRow.appendChild(secondCell);
 			for (j=0; j&lt;2;j++) {
 				var nextCell = document.createElement('td');
 				thisRow.appendChild(nextCell);
 				}
 			}
 		for (i=0; i&lt;SODepartments.length; i++) {
 			var dept = SODepartments[i];
 			var thisRow = document.createElement('tr');
 			creditTable.appendChild(thisRow);
 			var firstCell = document.createElement('td');
 			firstCell.innerHTML = '&lt;div&gt;Special Orders D' + dept + ': ';
 			thisRow.appendChild(firstCell);
 			var secondCell = document.createElement('td');
 			secondCell.innerHTML =  moneyFormat(Math.round(SODepartmentTotals[dept] * 100) / 100);
 			thisRow.appendChild(secondCell);
 			for (j=0; j&lt;2;j++) {
 				var nextCell = document.createElement('td');
 				thisRow.appendChild(nextCell);
 				}
 			}
 		depts.splice(depts.indexOf('99'), 1);
 		body.innerHTML += &quot;&lt;h3&gt;Review of Receiving PO's&lt;/h3&gt;&quot;;
 		var deptTable = document.createElement('table');
 		body.appendChild(deptTable);
 		var deptHeaderRow = document.createElement('tr');
 		deptTable.appendChild(deptHeaderRow);
 		var firstDeptHeader = document.createElement('td');
 		deptHeaderRow.appendChild(firstDeptHeader);
 		var secondDeptHeader = document.createElement('td');
 		secondDeptHeader.innerHTML = 'Double Key-rec';
 		deptHeaderRow.appendChild(secondDeptHeader);
 		var thirdDeptHeader = document.createElement('td');
 		thirdDeptHeader.innerHTML = 'Negative IMU';
 		deptHeaderRow.appendChild(thirdDeptHeader);
 		var fourthDeptHeader = document.createElement('td');
 		fourthDeptHeader.innerHTML = 'Greater than 25,000';
 		deptHeaderRow.appendChild(fourthDeptHeader);
 		for(i=0; i&lt;depts.length; i++) {
 			var dept = depts[i];
 			var thisRow = document.createElement('tr');
 			deptTable.appendChild(thisRow);

 			var firstCell = document.createElement('td');
 			firstCell.innerHTML = 'D' + dept;
 			thisRow.appendChild(firstCell);

 			var secondCell = document.createElement('td');
 			var duplicateText = '';
 			for (j=0; j&lt;anomalies[dept]['duplicate'].length; j++) {
 				var duplicate = anomalies[dept]['duplicate'][j];
 				duplicateText += '(' + duplicate[0] + ', ' + duplicate[1] + ') ';
 				}
 			secondCell.innerHTML = duplicateText;
 			thisRow.appendChild(secondCell);

 			var thirdCell = document.createElement('td');
 			thisRow.appendChild(thirdCell);
 			var imuTable = document.createElement('table');
 			thirdCell.appendChild(imuTable);
 			var IMUText = '';
 			for (j=0; j&lt;Object.keys(anomalies[dept]['IMU']).length; j++) {
 				key = Object.keys(anomalies[dept]['IMU'])[j];
 				var typeList = anomalies[dept]['IMU'][key];
 				var keyDiv = document.createElement('div');
 				thirdCell.appendChild(keyDiv);
 				keyDiv.className = 'clearBoth';
 				var keySpan = document.createElement('span');
 				keySpan.className = 'floatLeft';
 				keyDiv.appendChild(keySpan);
 				keySpan.innerHTML = key + ': ';
 				var valueSpan = document.createElement('span');
 				valueSpan.className = 'floatRight';
 				keyDiv.appendChild(valueSpan);
 				IMUText = '';
 				for (k=0; k&lt;typeList.length; k++) {
 					var IMU = anomalies[dept]['IMU'][key][k];
 					IMUText += '&lt;span class=&quot;nobr&quot;&gt;(' + IMU[0] + ', ' + IMU[1] + ')&lt;/span&gt; ';
 					}
 				valueSpan.innerHTML = IMUText;
 				}

 			var fourthCell = document.createElement('td');
 			thisRow.appendChild(fourthCell);
 			var bigText = '';
 			for (j=0; j&lt;anomalies[dept]['big'].length; j++) {
 				var big = anomalies[dept]['big'][j];
 				bigText += '(' + big[0] + ', ' + big[1] + ') ';
 				}
 			fourthCell.innerHTML = bigText;
 			}


 		body.innerHTML += &quot;&lt;h3&gt;Department Overview&lt;/h3&gt;&quot;;
 		body.innerHTML += '&lt;h5&gt;(Cost, Retail, IMU)&lt;/h5&gt;';
 		var overviewTable = document.createElement('table');
 		body.appendChild(overviewTable);
 		for (i=0; i&lt;depts.length; i++) {
 			thisDept = depts[i];
 			var firstRow = document.createElement('tr');
 			overviewTable.appendChild(firstRow);
 			var firstRowFirstCell = document.createElement('td');
 			firstRowFirstCell.innerHTML = thisDept;
 			firstRow.appendChild(firstRowFirstCell);
 			for (j=0; j&lt;worthwhilePOTypes.length; j++) {
 				var thisHeaderCell = document.createElement('td');
 				thisHeaderCell.innerHTML = worthwhilePOTypes[j];
 				firstRow.appendChild(thisHeaderCell);
 				}
 			var firstRowLastCell = document.createElement('td');
 			firstRowLastCell.innerHTML = 'Total';
 			firstRow.appendChild(firstRowLastCell);
 			var nextRows = ['Cost', 'Retail', 'IMU'];
 			var costTotal = 0;
 			var retailTotal = 0;
 			for (j=0; j&lt;nextRows.length; j++) {
 				var thisRowType = nextRows[j];
 				var thisRow = document.createElement('tr');
 				overviewTable.appendChild(thisRow);
 				var thisRowTotal = 0;
 				var thisRowFirstCell = document.createElement('td');
 				thisRow.appendChild(thisRowFirstCell);
 				for (var k=0; k&lt;worthwhilePOTypes.length+1; k++) {
 					var thisCell = document.createElement('td');
 					thisRow.appendChild(thisCell);
 					if (k==worthwhilePOTypes.length) {
 						if (thisRowType == 'Cost') {
 							thisCell.innerHTML = moneyFormat(thisRowTotal);
 							costTotal = thisRowTotal;
 							}
 						else if (thisRowType == 'Retail') {
 							thisCell.innerHTML = moneyFormat(thisRowTotal);
 							retailTotal = thisRowTotal;
 							}
 						else if (thisRowType == 'IMU') {
 							thisCell.innerHTML = moneyFormat((retailTotal-costTotal)*100/costTotal) + '% ($' + moneyFormat(retailTotal-costTotal) + ')';
 							}
 						}
 					else if (thisRowType == 'Cost') {
 						var cost = deptTotals[thisDept][worthwhilePOTypes[k]][0];
 						thisCell.innerHTML = moneyFormat(cost);
 						thisRowTotal += cost;
 						}
 					else if (thisRowType == 'Retail') {
 						var retail = deptTotals[thisDept][worthwhilePOTypes[k]][1];
 						thisCell.innerHTML = moneyFormat(retail);
 						thisRowTotal += retail;
 						}
 					else if (thisRowType == 'IMU') {
 						var cost = deptTotals[thisDept][worthwhilePOTypes[k]][0];
 						var retail = deptTotals[thisDept][worthwhilePOTypes[k]][1];
 						if (cost == 0) {
 							if (retail &gt; 0) {
 								thisCell.innerHTML = '100%';
 								}
 							else {
 								thisCell.innerHTML = 'N/A';
 								}
 							}
 						else {
 							thisCell.innerHTML = moneyFormat((retail-cost)*100/cost) + '%, ($' + moneyFormat(retail-cost) + ')';
 							}
 						}
 					}
 				}

 			}
 		}
 	}

 }
        </code>
      </pre>
    </figure>
  </div>

</body>
</html>
